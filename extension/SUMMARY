---
File: extension/background.js
---
// background.js
import { loadSessionConfig, getConfigurationInMs } from './config/session.js';

let githubToken = '';
let githubRepo = '';
let currentPaperData = null;
let currentSession = null;
let activityInterval = null;
let activityTimeout = null;
let sessionConfig = null;

// Load credentials and configuration when extension starts
async function loadCredentials() {
    const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);
    githubToken = items.githubToken || '';
    githubRepo = items.githubRepo || '';
    console.log('Credentials loaded:', { hasToken: !!githubToken, hasRepo: !!githubRepo });
    
    // Load session configuration
    sessionConfig = getConfigurationInMs(await loadSessionConfig());
    console.log('Session configuration loaded:', sessionConfig);
}

// Listen for credential changes
chrome.storage.onChanged.addListener(async (changes) => {
    console.log('Storage changes detected:', Object.keys(changes));
    if (changes.githubToken) {
        githubToken = changes.githubToken.newValue;
    }
    if (changes.githubRepo) {
        githubRepo = changes.githubRepo.newValue;
    }
    if (changes.sessionConfig) {
        sessionConfig = getConfigurationInMs(changes.sessionConfig.newValue);
        console.log('Session configuration updated:', sessionConfig);
    }
});

// Reading Session class to track individual reading sessions
class ReadingSession {
    constructor(arxivId, config) {
        this.arxivId = arxivId;
        this.startTime = Date.now();
        this.activeTime = 0;
        this.lastActiveTime = Date.now();
        this.isTracking = true;
        this.config = config;
    }

    update() {
        if (this.isTracking) {
            const now = Date.now();
            const timeSinceLastActive = now - this.lastActiveTime;
            
            if (timeSinceLastActive < this.config.idleThreshold) {
                this.activeTime += timeSinceLastActive;
            } else if (this.config.requireContinuousActivity) {
                // Reset active time if continuous activity is required
                this.activeTime = 0;
            }
            
            this.lastActiveTime = now;
        }
    }

    end() {
        this.isTracking = false;
        this.update();
        
        if (this.config.logPartialSessions) {
            return this.activeTime;
        }
        return this.activeTime >= this.config.minSessionDuration ? this.activeTime : 0;
    }
}

// Initialize credentials
loadCredentials();

// Listen for URL changes
chrome.webNavigation.onCompleted.addListener(async (details) => {
    console.log('Navigation detected:', details.url);
    if (details.url.includes('arxiv.org')) {
        console.log('arXiv URL detected, processing...');
        const paperData = await processArxivUrl(details.url);
        if (paperData) {
            console.log('Paper data extracted:', paperData);
            await createGithubIssue(paperData);
        } else {
            console.log('Failed to extract paper data');
        }
    }
}, {
    url: [{
        hostSuffix: 'arxiv.org'
    }]
});

// Message passing between background and popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    console.log('Message received:', request);
    
    if (request.type === 'getCurrentPaper') {
        console.log('Popup requested current paper:', currentPaperData);
        sendResponse(currentPaperData);
    }
    else if (request.type === 'updateRating') {
        console.log('Rating update requested:', request.rating);
        if (currentPaperData && currentPaperData.issueNumber) {
            updatePaperRating(currentPaperData.issueNumber, request.rating)
                .then(() => {
                    currentPaperData.rating = request.rating;
                    sendResponse({success: true});
                })
                .catch(error => {
                    console.error('Error updating rating:', error);
                    sendResponse({success: false, error: error.message});
                });
            return true; // Will respond asynchronously
        } else {
            sendResponse({success: false, error: 'No current paper or issue number'});
        }
    }
    return true;
});

// Tab and window management
chrome.tabs.onActivated.addListener(async (activeInfo) => {
    const tab = await chrome.tabs.get(activeInfo.tabId);
    handleTabChange(tab);
});

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete') {
        handleTabChange(tab);
    }
});

chrome.windows.onFocusChanged.addListener((windowId) => {
    if (windowId === chrome.windows.WINDOW_ID_NONE) {
        endCurrentSession();
    }
});

async function handleTabChange(tab) {
    const isArxiv = tab.url?.includes('arxiv.org/');
    console.log('Tab change detected:', { isArxiv, url: tab.url });
    
    if (!isArxiv) {
        console.log('Not an arXiv page, ending current session');
        await endCurrentSession();
        return;
    }

    // End any existing session before starting a new one
    if (currentSession) {
        console.log('Ending existing session before starting new one');
        await endCurrentSession();
    }

    // Always process the URL and start a new session
    console.log('Processing arXiv URL for new session');
    currentPaperData = await processArxivUrl(tab.url);
    if (currentPaperData) {
        console.log('Starting new session for:', currentPaperData.arxivId);
        currentSession = new ReadingSession(currentPaperData.arxivId, sessionConfig);
        startActivityTracking();
    }
}

async function endCurrentSession() {
    if (currentSession && currentPaperData) {
        console.log('Ending session for:', currentPaperData.arxivId);
        const duration = currentSession.end();
        if (duration > 0) {
            console.log('Creating reading event with duration:', duration);
            await createReadingEvent(currentPaperData, duration);
        }
        currentSession = null;
        currentPaperData = null;
        stopActivityTracking();
    }
}

function startActivityTracking() {
    if (!activityInterval) {
        console.log('Starting activity tracking');
        activityInterval = setInterval(() => {
            if (currentSession) {
                currentSession.update();
            }
        }, sessionConfig.activityUpdateInterval);
    }
}

function stopActivityTracking() {
    if (activityInterval) {
        clearInterval(activityInterval);
        activityInterval = null;
    }
    if (activityTimeout) {
        clearTimeout(activityTimeout);
        activityTimeout = null;
    }
}

async function createReadingEvent(paperData, sessionDuration) {
    if (!githubToken || !githubRepo || !paperData) {
        console.error('Missing required data for creating reading event:', {
            hasToken: !!githubToken,
            hasRepo: !!githubRepo,
            hasPaperData: !!paperData
        });
        return;
    }

    const seconds = Math.round(sessionDuration / 1000);
    if (sessionDuration < sessionConfig.minSessionDuration) {
        console.log('Session too short to log:', seconds, 'seconds');
        return;
    }

    console.log('Creating reading event:', {
        arxivId: paperData.arxivId,
        duration: seconds,
        title: paperData.title
    });

    const eventData = {
        type: 'reading_session',
        arxivId: paperData.arxivId, // TODO: change to arxiv_id throughout
        timestamp: new Date().toISOString(),
        duration_seconds: seconds,
        title: paperData.title,
        authors: paperData.authors,
        abstract: paperData.abstract,
        url: paperData.url,
        session_config: {
            idle_threshold_seconds: sessionConfig.idleThreshold / 1000,
            min_duration_seconds: sessionConfig.minSessionDuration / 1000,
            continuous_activity_required: sessionConfig.requireContinuousActivity,
            partial_sessions_logged: sessionConfig.logPartialSessions
        }
    };

    const issueBody = JSON.stringify(eventData, null, 2);

    try {
        const response = await fetch(`https://api.github.com/repos/${githubRepo}/issues`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${githubToken}`,
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify({
                title: `[Reading] ${paperData.title || paperData.arxivId} (${seconds}s)`,
                body: issueBody,
                labels: ['reading-session']
            })
        });

        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status}`);
        }

        const issueData = await response.json();
        console.log('Reading event created:', issueData.html_url);
        return issueData;
    } catch (error) {
        console.error('Error creating reading event:', error);
    }
}

// Update parseXMLText function to extract publication date and categories
async function parseXMLText(xmlText) {
    console.log('Parsing XML response...');
    try {
        const getTagContent = (tag, text) => {
            const entryRegex = /<entry>([\s\S]*?)<\/entry>/;
            const entryMatch = text.match(entryRegex);
            
            if (entryMatch) {
                const entryContent = entryMatch[1];
                const regex = new RegExp(`<${tag}[^>]*>(.*?)</${tag}>`, 's');
                const match = entryContent.match(regex);
                return match ? match[1].trim() : '';
            }
            return '';
        };
        
        const getAuthors = (text) => {
            const authors = [];
            const regex = /<author>[^]*?<name>([^]*?)<\/name>[^]*?<\/author>/g;
            let match;
            while (match = regex.exec(text)) {
                authors.push(match[1].trim());
            }
            return authors;
        };

        // Extract categories/tags
        const getCategories = (text) => {
            const categories = new Set();
            
            // Get primary category
            const primaryMatch = text.match(/<arxiv:primary_category[^>]*term="([^"]+)"/);
            if (primaryMatch) {
                categories.add(primaryMatch[1]);
            }
            
            // Get all categories
            const categoryRegex = /<category[^>]*term="([^"]+)"/g;
            let match;
            while (match = categoryRegex.exec(text)) {
                categories.add(match[1]);
            }
            
            return Array.from(categories);
        };

        // Get publication date (first version)
        const getPublishedDate = (text) => {
            const match = text.match(/<published>([^<]+)<\/published>/);
            return match ? match[1].trim() : null;
        };

        const parsed = {
            title: getTagContent('title', xmlText),
            summary: getTagContent('summary', xmlText),
            authors: getAuthors(xmlText),
            published_date: getPublishedDate(xmlText),
            arxiv_tags: getCategories(xmlText)
        };
        
        console.log('Parsed XML:', parsed);
        return parsed;
    } catch (error) {
        console.error('Error parsing XML:', error);
        return null;
    }
}

// Update processArxivUrl function to include new fields
async function processArxivUrl(url) {
    console.log('Processing URL:', url);
    
    const patterns = [
        /arxiv\.org\/abs\/([0-9.]+)/,
        /arxiv\.org\/pdf\/([0-9.]+)\.pdf/,
        /arxiv\.org\/\w+\/([0-9.]+)/
    ];
    
    let arxivId = null;
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) {
            arxivId = match[1];
            break;
        }
    }
    
    if (!arxivId) {
        console.log('No arXiv ID found in URL');
        return null;
    }
    
    console.log('Found arXiv ID:', arxivId);
    
    try {
        const apiUrl = `http://export.arxiv.org/api/query?id_list=${arxivId}`;
        console.log('Fetching from arXiv API:', apiUrl);
        
        const response = await fetch(apiUrl);
        console.log('API response status:', response.status);
        
        const text = await response.text();
        const parsed = await parseXMLText(text);
        
        if (!parsed) {
            console.log('Failed to parse API response');
            return null;
        }
        
        const paperData = {
            arxivId,
            url,
            title: parsed.title,
            authors: parsed.authors.join(", "),
            abstract: parsed.summary,
            timestamp: new Date().toISOString(),
            rating: 'novote',
            published_date: parsed.published_date,
            arxiv_tags: parsed.arxiv_tags
        };
        
        console.log('Paper data processed:', paperData);
        return paperData;
    } catch (error) {
        console.error('Error processing arXiv URL:', error);
        return null;
    }
}

// Update createGithubIssue to add tags to labels
async function createGithubIssue(paperData) {
    if (!githubToken || !githubRepo) {
        console.error('GitHub credentials not set. Please configure extension options.');
        return;
    }

    try {
        console.log('Creating GitHub issue for paper:', paperData.arxivId);
        const issueBody = JSON.stringify(paperData, null, 2);

        // Create issue labels starting with paper and rating
        const issueLabels = ['paper', `rating:${paperData.rating}`];
        
        // // Add arXiv tags as labels if they exist
        // if (paperData.arxiv_tags && paperData.arxiv_tags.length > 0) {
        //     // Add tags in format "arxiv:cs.AI", "arxiv:cs.LG", etc.
        //     issueLabels.push(...paperData.arxiv_tags.map(tag => `arxiv:${tag}`));
        // }

        const response = await fetch(`https://api.github.com/repos/${githubRepo}/issues`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${githubToken}`,
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify({
                title: `[Paper] ${paperData.title || paperData.arxivId}`,
                body: issueBody,
                labels: issueLabels
            })
        });

        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status}`);
        }

        const issueData = await response.json();
        console.log('GitHub issue created successfully:', issueData.html_url);
        return issueData;
    } catch (error) {
        console.error('Error creating Github issue:', error);
    }
}

async function updatePaperRating(issueNumber, rating) {
    if (!githubToken || !githubRepo) {
        console.error('GitHub credentials not set. Please configure extension options.');
        return;
    }

    try {
        console.log(`Updating rating for issue ${issueNumber} to ${rating}`);
        
        // Update issue labels
        await fetch(`https://api.github.com/repos/${githubRepo}/issues/${issueNumber}/labels`, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${githubToken}`,
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify([
                'paper',
                `rating:${rating}`
            ])
        });

        // Add comment about rating change
        await fetch(`https://api.github.com/repos/${githubRepo}/issues/${issueNumber}/comments`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${githubToken}`,
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify({
                body: `Updated paper rating to: ${rating}`
            })
        });

        console.log('Rating updated successfully');
    } catch (error) {
        console.error('Error updating rating:', error);
        throw error;
    }
}



---
File: extension/config/session.js
---
// extension/config/session.js

// Default configuration values
const DEFAULT_CONFIG = {
    idleThresholdMinutes: 5,
    minSessionDurationSeconds: 30,
    // Adding more granular control
    requireContinuousActivity: true,  // If true, resets timer on idle
    logPartialSessions: false,        // If true, logs sessions even if under minimum duration
    activityUpdateIntervalSeconds: 1  // How often to update active time
};

// Load session configuration from storage
async function loadSessionConfig() {
    const items = await chrome.storage.sync.get('sessionConfig');
    return { ...DEFAULT_CONFIG, ...items.sessionConfig };
}

// Save session configuration to storage
async function saveSessionConfig(config) {
    await chrome.storage.sync.set({
        sessionConfig: {
            idleThresholdMinutes: Number(config.idleThresholdMinutes),
            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),
            requireContinuousActivity: Boolean(config.requireContinuousActivity),
            logPartialSessions: Boolean(config.logPartialSessions),
            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)
        }
    });
}

// Convert configuration to milliseconds for internal use
function getConfigurationInMs(config) {
    return {
        idleThreshold: config.idleThresholdMinutes * 60 * 1000,
        minSessionDuration: config.minSessionDurationSeconds * 1000,
        activityUpdateInterval: config.activityUpdateIntervalSeconds * 1000,
        requireContinuousActivity: config.requireContinuousActivity,
        logPartialSessions: config.logPartialSessions
    };
}

export { loadSessionConfig, saveSessionConfig, getConfigurationInMs, DEFAULT_CONFIG };


---
File: extension/manifest.json
---
{
  "manifest_version": 3,
  "name": "ArXiv Paper Tracker",
  "version": "1.0",
  "description": "Track and rate arXiv papers you read",
  "permissions": [
    "tabs",
    "storage",
    "webNavigation"
  ],
  "host_permissions": [
    "*://arxiv.org/*",
    "*://api.github.com/*"
  ],
  "background": {
    "service_worker": "background.js",
    "type": "module"
  },
  "action": {
    "default_popup": "popup.html"
  },
  "options_ui": {
    "page": "options.html",
    "open_in_tab": false
  }
}


---
File: extension/options.html
---
<!DOCTYPE html>
<html>
<head>
  <title>ArXiv Tracker Settings</title>
  <style>
    body {
      padding: 20px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .container {
      max-width: 500px;
      margin: 0 auto;
    }
    .field {
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    input[type="text"],
    input[type="password"],
    input[type="number"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }
    input[type="number"] {
      width: 100px;
    }
    .help-text {
      font-size: 0.9em;
      color: #666;
      margin-top: 4px;
    }
    .status {
      margin-top: 16px;
      padding: 8px;
      border-radius: 4px;
    }
    .success {
      background: #e6ffe6;
      color: #006600;
    }
    .error {
      background: #ffe6e6;
      color: #660000;
    }
    button {
      background: #0366d6;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
    }
    button:hover {
      background: #0255b3;
    }
    .section {
      margin-bottom: 32px;
    }
    .section-title {
      font-size: 1.2em;
      font-weight: 600;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    .checkbox-field {
      margin-top: 12px;
    }
    .checkbox-field label {
      display: flex;
      align-items: center;
      font-weight: normal;
    }
    .checkbox-field input[type="checkbox"] {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ArXiv Tracker Settings</h2>
    
    <div class="section">
      <div class="section-title">GitHub Integration</div>
      <div class="field">
        <label for="repo">GitHub Repository</label>
        <input type="text" id="repo" placeholder="username/repository">
        <div class="help-text">Format: username/repository (e.g., johndoe/arxiv-tracker)</div>
      </div>

      <div class="field">
        <label for="token">GitHub Personal Access Token</label>
        <input type="password" id="token" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx">
        <div class="help-text">
          Token needs 'repo' scope for private repositories.<br>
          Never share this token with anyone.
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Reading Session Settings</div>
      
      <div class="field">
        <label for="idleThreshold">Idle Threshold (minutes)</label>
        <input type="number" id="idleThreshold" min="1" max="60" value="5">
        <div class="help-text">
          Time of inactivity before session is paused (1-60 minutes).<br>
          Default: 5 minutes
        </div>
      </div>

      <div class="field">
        <label for="minDuration">Minimum Session Duration (seconds)</label>
        <input type="number" id="minDuration" min="10" max="300" value="30">
        <div class="help-text">
          Minimum time required to log a reading session (10-300 seconds).<br>
          Default: 30 seconds
        </div>
      </div>

      <div class="checkbox-field">
        <label>
          <input type="checkbox" id="requireContinuous">
          Require Continuous Activity
        </label>
        <div class="help-text">
          When enabled, resets the session timer if you're idle for too long.<br>
          Default: Enabled
        </div>
      </div>

      <div class="checkbox-field">
        <label>
          <input type="checkbox" id="logPartial">
          Log Partial Sessions
        </label>
        <div class="help-text">
          When enabled, logs sessions even if they're shorter than the minimum duration.<br>
          Default: Disabled
        </div>
      </div>
    </div>

    <button id="save">Save Settings</button>
    <div id="status" class="status"></div>
  </div>
  <script type="module" src="options.js"></script>
</body>
</html>


---
File: extension/options.js
---
// options.js
import { loadSessionConfig, DEFAULT_CONFIG, saveSessionConfig } from './config/session.js';

// Helper to set form field values
function setFormValues(settings) {
  // GitHub settings
  if (settings.githubRepo) {
    document.getElementById('repo').value = settings.githubRepo;
  }
  if (settings.githubToken) {
    // Don't show the actual token, just indicate it's set
    document.getElementById('token').placeholder = '••••••••••••••••••••••';
  }

  // Session settings
  document.getElementById('idleThreshold').value = settings.sessionConfig?.idleThresholdMinutes ?? DEFAULT_CONFIG.idleThresholdMinutes;
  document.getElementById('minDuration').value = settings.sessionConfig?.minSessionDurationSeconds ?? DEFAULT_CONFIG.minSessionDurationSeconds;
  document.getElementById('requireContinuous').checked = settings.sessionConfig?.requireContinuousActivity ?? DEFAULT_CONFIG.requireContinuousActivity;
  document.getElementById('logPartial').checked = settings.sessionConfig?.logPartialSessions ?? DEFAULT_CONFIG.logPartialSessions;
}

// Helper to get form values
function getFormValues() {
  return {
    githubRepo: document.getElementById('repo').value.trim(),
    githubToken: document.getElementById('token').value.trim(),
    sessionConfig: {
      idleThresholdMinutes: Number(document.getElementById('idleThreshold').value),
      minSessionDurationSeconds: Number(document.getElementById('minDuration').value),
      requireContinuousActivity: document.getElementById('requireContinuous').checked,
      logPartialSessions: document.getElementById('logPartial').checked
    }
  };
}

// Display status message
function showStatus(message, isError = false) {
  const status = document.getElementById('status');
  status.textContent = message;
  status.className = `status ${isError ? 'error' : 'success'}`;

  // Clear status after 3 seconds if it's a success message
  if (!isError) {
    setTimeout(() => {
      status.textContent = '';
      status.className = 'status';
    }, 3000);
  }
}

// Validate settings before saving
async function validateSettings(settings) {
  // Validate repository format
  if (!/^[\w-]+\/[\w-]+$/.test(settings.githubRepo)) {
    throw new Error('Invalid repository format. Use username/repository');
  }

  // Validate the token by making a test API call
  const response = await fetch(`https://api.github.com/repos/${settings.githubRepo}`, {
    headers: {
      'Authorization': `token ${settings.githubToken}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  });

  if (!response.ok) {
    throw new Error('Invalid token or repository. Please check your credentials.');
  }

  // Validate session settings
  const { sessionConfig } = settings;
  if (sessionConfig.idleThresholdMinutes < 1 || sessionConfig.idleThresholdMinutes > 60) {
    throw new Error('Idle threshold must be between 1 and 60 minutes');
  }
  if (sessionConfig.minSessionDurationSeconds < 1 || sessionConfig.minSessionDurationSeconds > 300) {
    throw new Error('Minimum session duration must be between 10 and 300 seconds');
  }
}

// Save settings
async function saveSettings(settings) {
  await chrome.storage.sync.set({
    githubRepo: settings.githubRepo,
    githubToken: settings.githubToken
  });

  await saveSessionConfig(settings.sessionConfig);
}

// Initialize options page
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // Load current settings
    const [storageItems, sessionConfig] = await Promise.all([
      chrome.storage.sync.get(['githubRepo', 'githubToken']),
      loadSessionConfig()
    ]);

    // Combine settings and display them
    setFormValues({
      ...storageItems,
      sessionConfig
    });

    // Add save button handler
    document.getElementById('save').addEventListener('click', async () => {
      try {
        const settings = getFormValues();
        await validateSettings(settings);
        await saveSettings(settings);
        showStatus('Settings saved successfully!');
      } catch (error) {
        showStatus(`Error: ${error.message}`, true);
      }
    });

  } catch (error) {
    showStatus(`Error loading settings: ${error.message}`, true);
  }
});


---
File: extension/popup.html
---
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      width: 400px;
      padding: 15px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .paper-info {
      margin-bottom: 15px;
    }
    .paper-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
    }
    .paper-authors {
      font-size: 12px;
      color: #666;
      margin-bottom: 12px;
      line-height: 1.4;
    }
    .rating-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    button {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f5f5f5;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:not(:disabled):hover {
      background: #e5e5e5;
    }
    .status {
      margin-top: 10px;
      font-size: 12px;
      color: #666;
      padding: 8px;
      background: #f5f5f5;
      border-radius: 4px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="currentPaper" class="paper-info">
    <div id="paperTitle" class="paper-title">Loading...</div>
    <div id="paperAuthors" class="paper-authors"></div>
    <div class="rating-buttons">
      <button id="thumbsUp" disabled>👍 Interesting</button>
      <button id="thumbsDown" disabled>👎 Not Relevant</button>
    </div>
    <div id="status" class="status">Loading paper details...</div>
  </div>
  <script src="popup.js"></script>
</body>
</html>



---
File: extension/popup.js
---
// popup.js
let currentIssueNumber = null;

// Function to get paper data from background script
async function getCurrentPaper() {
  return new Promise((resolve) => {
    chrome.runtime.sendMessage({type: 'getCurrentPaper'}, response => {
      console.log('Got paper data from background:', response);
      resolve(response);
    });
  });
}

// Function to update UI with paper data
function updateUI(paperData) {
  const titleElement = document.getElementById('paperTitle');
  const authorsElement = document.getElementById('paperAuthors');
  const statusElement = document.getElementById('status');

  if (paperData) {
    titleElement.textContent = paperData.title || paperData.arxivId;
    authorsElement.textContent = paperData.authors;
    statusElement.textContent = 'Paper tracked! Issue created on GitHub.';
    
    // Enable rating buttons
    document.getElementById('thumbsUp').disabled = false;
    document.getElementById('thumbsDown').disabled = false;
  } else {
    titleElement.textContent = 'No arXiv paper detected';
    authorsElement.textContent = '';
    statusElement.textContent = 'Visit an arXiv paper to track it';
    
    // Disable rating buttons
    document.getElementById('thumbsUp').disabled = true;
    document.getElementById('thumbsDown').disabled = true;
  }
}

// Initialize popup
document.addEventListener('DOMContentLoaded', async () => {
  console.log('Popup opened');
  
  // Get current tab
  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  console.log('Current tab:', tab.url);
  
  if (tab.url.includes('arxiv.org')) {
    console.log('On arXiv page, getting paper data...');
    // Try multiple times to get paper data, as it might not be ready immediately
    let retries = 3;
    let paperData = null;
    
    while (retries > 0 && !paperData) {
      paperData = await getCurrentPaper();
      if (!paperData) {
        await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
        retries--;
      }
    }
    
    updateUI(paperData);
    
    // Set up rating handlers
    document.getElementById('thumbsUp').addEventListener('click', () => {
      chrome.runtime.sendMessage({
        type: 'updateRating',
        rating: 'thumbsup'
      }, response => {
        if (response && response.success) {
          document.getElementById('status').textContent = 'Rating updated to: thumbs up';
          setTimeout(() => window.close(), 1500);
        }
      });
    });
    
    document.getElementById('thumbsDown').addEventListener('click', () => {
      chrome.runtime.sendMessage({
        type: 'updateRating',
        rating: 'thumbsdown'
      }, response => {
        if (response && response.success) {
          document.getElementById('status').textContent = 'Rating updated to: thumbs down';
          setTimeout(() => window.close(), 1500);
        }
      });
    });
  } else {
    updateUI(null);
  }
});


