---
abstract: |
  In the 1990s, the constant error carousel and gating were introduced as the central ideas of the Long Short-Term Memory (LSTM). Since then, LSTMs have stood the test of time and contributed to numerous deep learning success stories, in particular they constituted the first Large Language Models (LLMs). However, the advent of the Transformer technology with parallelizable self-attention at its core marked the dawn of a new era, outpacing LSTMs at scale. We now raise a simple question: How far do we get in language modeling when scaling LSTMs to billions of parameters, leveraging the latest techniques from modern LLMs, but mitigating known limitations of LSTMs? Firstly, we introduce exponential gating with appropriate normalization and stabilization techniques. Secondly, we modify the LSTM memory structure, obtaining: (i) sLSTM with a scalar memory, a scalar update, and new memory mixing, (ii) mLSTM that is fully parallelizable with a matrix memory and a covariance update rule. Integrating these LSTM extensions into residual block backbones yields xLSTM blocks that are then residually stacked into xLSTM architectures. Exponential gating and modified memory structures boost xLSTM capabilities to perform favorably when compared to state-of-the-art Transformers and State Space Models, both in performance and scaling.  
  Code available at: <https://github.com/NX-AI/xlstm>
author:
- |
      Maximilian Beck$^{* \ 1,2,3}$         Korbinian Pöppel$^{* \ 1,2,3}$           Markus Spanring$^{\ 1}$      
         **Andreas Auer**$^{\ 1,2}$        **Oleksandra Prudnikova**$^{\ 1}$            **Michael Kopp**           
      **Günter Klambauer**$^{\ 1,2,3}$     **Johannes Brandstetter**$^{\ 1,2,3}$      **Sepp Hochreiter**$^{\ 1,2,3}$  
  $^*$Equal contribution  
  $^1$ELLIS Unit, LIT AI Lab, Institute for Machine Learning, JKU Linz, Austria  
  $^2$NXAI Lab, Linz, Austria,    $^3$NXAI GmbH, Linz, Austria
bibliography:
- bibs/xLSTM.bib
citation-style: ieee
header-includes:
- 
- 
link-citations: true
reference-section-title: References
title: "xLSTM: Extended Long Short-Term Memory"
---





<figure>
<p><span class="image placeholder" data-original-image-src="figures/desc_xlstm_overview.pdf" data-original-image-title="" width="1.\textwidth">image</span> </p>
<figcaption>The extended LSTM (xLSTM) family. From left to right: 1. The original LSTM memory cell with constant error carousel and gating. 2. New sLSTM and mLSTM memory cells that introduce exponential gating. sLSTM offers a new memory mixing technique. mLSTM is fully parallelizable with a novel matrix memory cell state and new covariance update rule. 3. mLSTM and sLSTM in residual blocks yield xLSTM blocks. 4. Stacked xLSTM blocks give an xLSTM architecture. </figcaption>
</figure>

# Introduction

The Long Short-Term Memory (LSTM) ideas , i.e., the constant error carousel and gating, were introduced to overcome the vanishing gradient problem of recurrent neural networks : $$\begin{aligned}
\label{eq:lstm_idea}
  \eqnmarkbox[OliveGreen]{}{c_t} \ = \ \eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ \eqnmarkbox[OliveGreen]{}{c_{t-1}} \ + \ 
          \eqnmarkbox[xLSTMBlue]{}{\Ri_t} \  \eqnmarkbox[OliveGreen]{}{z_t} \ , \quad  
          h_t \ = \ \eqnmarkbox[xLSTMBlue]{}{\Ro_t} \ \psi({\eqnmarkbox[OliveGreen]{}{c_t}}) \ . 
\end{aligned}$$ The constant error carousel is the additive update of the cell state $c_{t-1}$ (green) by cell inputs $z_t$ and moderated by sigmoid gates (blue). The input gate $\Ri_t$ and the forget gate $\Rf_t$ control this update, while the output gate $\Ro_t$ controls the output of the memory cell, i.e. the hidden state $h_t$. The cell state is normalized or squashed by $\psi$ and then output gating gives the hidden state.

LSTMs have been successfully applied to various domains , and prevailed over text generation until the dawn of Transformers in 2017 . The effectiveness of LSTMs has been demonstrated at numerous sequence-related tasks such as generating text , generating handwritings , sequence-to-sequence translation , evaluating computer programs , generating image captions , generating source code , rainfall-runoff modeling , or hydrological models for flooding warnings . In reinforcement learning, LSTMs are the best performing sequence models, e.g., the AlphaStar model for StarCraft II , the OpenAI Five model for Dota 2 , and models of the magnetic controller for nuclear fusion . LSTMs excel at learning abstractions, i.e., adeptly extracting semantic information and storing it in their memory cells , which for example became evident by number and syntax neurons , linguistic neurons , and sentiment neurons . LSTMs are still used in highly relevant applications  and have stood the test of time.

Despite their tremendous successes, LSTMs have three main limitations: (i) Inability to revise storage decisions. We exemplify this limitation via the *Nearest Neighbor Search* problem (see also Appendix ): With a reference vector given, a sequence must be scanned sequentially for the most similar vector in order to provide its attached value at sequence end. The left panel of Figure  shows the mean squared error at this task. LSTM struggles to revise a stored value when a more similar vector is found, while our new xLSTM remediates this limitation by exponential gating. (ii) Limited storage capacities, i.e., information must be compressed into scalar cell states. We exemplify this limitation via *Rare Token Prediction*. In the right panel of Figure , the perplexity of token prediction on Wikitext-103  is given for partitions of different token frequency. LSTM performs worse on rare tokens because of its limited storage capacities. Our new xLSTM solves this problem by a matrix memory. (iii) Lack of parallelizability due to memory mixing, i.e., the hidden-hidden connections between hidden states from one time step to the next, which enforce sequential processing.

These limitations of LSTM have paved the way for the emergence of Transformers  in language modeling. What performances can we achieve in language modeling when overcoming these limitations and scaling LSTMs to the size of current Large Language Models?

# Extended Long Short-Term Memory

To overcome the LSTM limitations, Extended Long Short-Term Memory (xLSTM) introduces two main modifications to the LSTM idea of Equation . Those modifications — exponential gating and novel memory structures — enrich the LSTM family by two members: (i) the new sLSTM (see Section ) with a scalar memory, a scalar update, and memory mixing, and (ii) the new mLSTM (see Section ) with a matrix memory and a covariance (outer product) update rule, which is fully parallelizable. Both sLSTM and mLSTM enhance the LSTM through exponential gating. To enable parallelization, the mLSTM abandons memory mixing, i.e., the hidden-hidden recurrent connections. Both mLSTM and sLSTM can be extended to multiple memory cells, where sLSTM features memory mixing across cells. Further, the sLSTM can have multiple heads without memory mixing across the heads, but only memory mixing across cells within each head. This introduction of heads for sLSTM together with exponential gating establishes a new way of memory mixing. For mLSTM multiple heads and multiple cells are equivalent.

Integrating these new LSTM variants into residual block modules results in xLSTM blocks (see Section ). Residually stacking those xLSTM blocks in architectures provides xLSTM architectures (see Section ). See Figure  for the xLSTM architecture with its components.

## Review of the Long Short-Term Memory

The original LSTM idea  introduced the scalar memory cell as a central processing and storage unit that avoids vanishing gradients  through the constant error carousel (the cell state update). The memory cell contains three gates: input, output, and forget gate. The forget gate has been introduced by . The update rules of the LSTM memory cell at time step $t$ are: $$\begin{aligned}
\eqnmarkbox[OliveGreen]{}{c_t} \ &= \  \eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ \eqnmarkbox[OliveGreen]{}{c_{t-1}} \ + \ \eqnmarkbox[xLSTMBlue]{}{\Ri_t} \ \eqnmarkbox[OliveGreen]{}{z_t}
  &  & &\text{cell state} \\
h_t  \ &= \ \eqnmarkbox[xLSTMBlue]{}{\Ro_t} \ \tilde{h}_t \ , 
  & \tilde{h}_t \ &= \ \psi \left( \eqnmarkbox[OliveGreen]{}{c_t}\right)
  &\text{hidden state} \\
\eqnmarkbox[OliveGreen]{}{z_t} \ &= \ \varphi \left( \tilde{z}_t \right) \ , 
  &\tilde{z}_t \ &=  \ \Bw^\top_{z} \ \Bx_t \ + \
  r_{z}  h_{t-1} \ + \  b_{z} \ \
  &\text{cell input} \\
\eqnmarkbox[xLSTMBlue]{}{\Ri_t} \ &= \ \sigma \left( \tilde{\Ri}_t  \right) \ , 
  &\tilde{\Ri}_t \ &= \ \Bw^\top_{\Ri} \ \Bx_t \ + \
  r_{\Ri}  \ h_{t-1} \ + \  b_{\Ri} \ \
  &\text{input gate} \\
\eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ &= \ \sigma \left(  \tilde{\Rf}_t \right) \ , 
  &\tilde{\Rf}_t \ &= \ \Bw^\top_{\Rf} \ \Bx_t  \ + \
  r_{\Rf}  \ h_{t-1} \ + \  b_{\Rf} \ \
  &\text{forget gate} \\
\eqnmarkbox[xLSTMBlue]{}{\Ro_t} \ &= \ \sigma \left( \tilde{\Ro}_t \right) \ , 
  &\tilde{\Ro}_t  \ &= \ \Bw^\top_{\Ro} \ \Bx_t \ + \
  r_{\Ro}  \ h_{t-1} \ + \  b_{\Ro} \ \
  &\text{output gate} 
\end{aligned}$$ The weight vectors $\Bw_{z}$, $\Bw_{\Ri}$, $\Bw_{\Rf}$, and $\Bw_{\Ro}$ correspond to the input weight vectors between inputs $\Bx_t$ and cell input, input gate, forget gate, and output gate, respectively. The weights $r_{z}$, $r_{\Ri}$, $r_{\Rf}$, and $r_{\Ro}$ correspond to the recurrent weights between hidden state $h_{t-1}$ and cell input, input gate, forget gate, and output gate, respectively. $b_{z}$, $b_{\Ri}$, $b_{\Rf}$, and $b_{\Ro}$ are the corresponding bias terms. $\varphi$ and $\psi$ are the cell input and hidden state activation functions (typically $\tanh$). $\psi$ is used to normalize or squash the cell state, which would be unbounded otherwise. All gate activation functions are sigmoid, i.e., $\sigma \left( x \right)= 1/(1+\exp(-x))$. In later formulations, multiple scalar memory cells $\Bc_t \in \dR^{d}$ were combined in a vector, which allows the usage of recurrent weight matrices $\BR \in \dR^{d \times d}$ to mix the cell outputs of memory cells , for more details see Appendix . Ablation studies showed that all components of the memory cell are crucial .

## sLSTM

To empower LSTMs with the ability to revise storage decisions, we introduce exponential gates (red) together with normalization and stabilization. In particular, input and forget gates can have exponential activation functions. For normalization, we introduce a normalizer state that sums up the product of the input gate times all future forget gates.

The scalar sLSTM forward pass is: $$\begin{aligned}
\label{eq:slstmforward}
\eqnmarkbox[OliveGreen]{}{c_t} \ &= \  \eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ \eqnmarkbox[OliveGreen]{}{c_{t-1}} \ + \ \eqnmarkbox[xLSTMBlue]{}{\Ri_t} \ \eqnmarkbox[OliveGreen]{}{z_t} & & 
 &\text{cell state} \\
\eqnmarkbox[OliveGreen]{}{n_t} \ &= \  \eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ \eqnmarkbox[OliveGreen]{}{n_{t-1}} \ + \ \eqnmarkbox[xLSTMBlue]{}{\Ri_t}  & & 
 &\text{normalizer state} \\
h_t \ &= \ \eqnmarkbox[xLSTMBlue]{}{\Ro_t} \ \tilde{h}_t \ ,
  &\tilde{h}_t \ &= \ \eqnmarkbox[OliveGreen]{}{c_t} / \eqnmarkbox[OliveGreen]{}{n_t}
&\text{hidden state} \\
\eqnmarkbox[OliveGreen]{}{z_t} \ &= \ \varphi \left( \tilde{z}_t \right) \ , 
  &\tilde{z}_t \ &=  \ \Bw^\top_{z} \ \Bx_t \ + \
  r_{z}  h_{t-1} \ + \  b_{z}
  &\text{cell input} \\
\eqnmarkbox[xLSTMBlue]{}{\Ri_t} \ &= \ \eqnmarkbox[xLSTMRed]{}{\!\exp} \left( \tilde{\Ri}_t  \right) \ , 
  &\tilde{\Ri}_t \ &= \ \Bw^\top_{\Ri} \ \Bx_t \ + \
  r_{\Ri}  \ h_{t-1} \ + \  b_{\Ri}
  &\text{input gate} \\
\eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ &= \ \sigma \left(  \tilde{\Rf}_t \right) \ \text{OR} \
\eqnmarkbox[xLSTMRed]{}{\!\exp} \left(  \tilde{\Rf}_t \right) \ ,
  &\tilde{\Rf}_t \ &= \ \Bw^\top_{\Rf} \ \Bx_t  \ + \
  r_{\Rf}  \ h_{t-1} \ + \  b_{\Rf}
  &\text{forget gate} \\
\eqnmarkbox[xLSTMBlue]{}{\Ro_t} \ &= \ \sigma \left( \tilde{\Ro}_t \right) \ , 
  &\tilde{\Ro}_t  \ &= \ \Bw^\top_{\Ro} \ \Bx_t \ + \
  r_{\Ro}  \ h_{t-1} \ + \  b_{\Ro}
  &\text{output gate} 
\end{aligned}$$

We transfer the original LSTM gating techniques, i.e., input- and/or hidden-dependent gating plus bias term, to the new architectures. Exponential activation functions can lead to large values that cause overflows. Therefore, we stabilize gates with an additional state : $$\begin{aligned}
\label{eq:slstmstabil}
\eqnmarkbox[OliveGreen]{}{m_t} \ &= \ \max \left( \log ( \eqnmarkbox[xLSTMBlue]{}{\Rf_t} ) + \eqnmarkbox[OliveGreen]{}{m_{t-1}} , \log ( \eqnmarkbox[xLSTMBlue]{}{\Ri_t} ) \right) &\text{stabilizer state} \\
\eqnmarkbox[xLSTMBlue]{}{\Ri'_t} \ &= \ \eqnmarkbox[xLSTMRed]{}{\!\exp} \left( \log \left ( \eqnmarkbox[xLSTMBlue]{}{\Ri_t} \right) - \eqnmarkbox[OliveGreen]{}{m_t} \right) \ = \ \eqnmarkbox[xLSTMRed]{}{\!\exp} \left( \tilde{\Ri}_t - \eqnmarkbox[OliveGreen]{}{m_t} \right) \ \, 
  &\text{stabil. input gate} \\
\eqnmarkbox[xLSTMBlue]{}{\Rf'_t} \ &= \ \eqnmarkbox[xLSTMRed]{}{\!\exp} \left( \log \left( \eqnmarkbox[xLSTMBlue]{}{\Rf_t} \right) + \eqnmarkbox[OliveGreen]{}{m_{t-1}} - \eqnmarkbox[OliveGreen]{}{m_t} \right) \ \, 
  &\text{stabil. forget gate}
\end{aligned}$$

We show in Appendix , that replacing $\Rf_t$ by $\Rf'_t$ and $\Ri_t$ by $\Ri'_t$ in the forward pass does neither change the output of the whole network nor the derivatives of the loss with respect to the parameters.

#### New Memory Mixing.

sLSTM can have multiple memory cells like the original LSTM (see Appendix ). Multiple memory cells enable memory mixing via recurrent connections $\BR_{\Bz}$, $\BR_{\bfi}$, $\BR_{\bff}$, $\BR_{\bfo}$ from hidden state vector $\Bh$ to memory cell input $\Bz$ and the gates $\bfi$, $\bff$, $\bfo$, respectively. A new aspect in memory mixing is the effect of exponential gating. The new sLSTM can have multiple heads with memory mixing within each head but not across heads. The introduction of heads for sLSTM together with exponential gating establishes a new way of memory mixing.

## mLSTM

To enhance storage capacities of LSTMs, we increase the LSTM memory cell from a scalar $c \in \dR$ to a matrix $\BC \in \dR^{d \times d}$. Hence, retrieval is performed via a matrix multiplication. At time $t$, we want to store a pair of vectors, the key $\Bk_t \in \dR^d$ and the value $\Bv_t \in \dR^d$ (we use the Transformer terminology). Later at time $t + \tau$, the value $\Bv_t$ should be retrieved by a query vector $\Bq_{t+\tau} \in \dR^d$. This is the setting of Bidirectional Associative Memories (BAMs) . The covariance update rule  for storing a key-value pair is $$\begin{aligned}
\BC_t \ &= \ \BC_{t-1} \ + \ \Bv_{t} \ \Bk_t^\top \ .
\end{aligned}$$ We assume a layer-norm before projecting inputs to keys and values, therefore they have zero mean. The covariance update rule is optimal  for a maximal separability of retrieved binary vectors, which is equivalent to a maximal signal/noise ratio. Higher separability is possible when limiting retrieval to pairwise interactions and conceding quadratic complexity like attention . The covariance update rule is equivalent to Fast Weight Programmers , which have later been equipped with a constant decay rate multiplied to $\BC_{t-1}$ and a constant learning rate multiplied to $\Bv_{t} \Bk_t ^\top$ . In this spirit, we integrate the covariance update rule into the LSTM framework, where the forget gate corresponds to decay rate and the input gate to the learning rate, while the output gate scales the retrieved vector.

For this matrix memory, the normalizer state is the weighted sum of key vectors, where each key vector is weighted by the input gate and all future forget gates. Again, the normalizer state keeps record of the strength of the gates. Since the dot product between query and normalizer state can be close to zero, we use the absolute value of this dot product and lower bound it by a threshold (typically 1.0) as done previously . The mLSTM forward pass is: $$\begin{aligned}
\label{eq:mlstm_recurrent_begin}
\eqnmarkbox[OliveGreen]{}{\BC_t} \ &= \  \eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ \eqnmarkbox[OliveGreen]{}{\BC_{t-1}} \ + \ 
  \eqnmarkbox[xLSTMBlue]{}{\Ri_t} \ \eqnmarkbox[OliveGreen]{}{\Bv_t \ \Bk_t^\top} & &  &\text{cell state} \\
\eqnmarkbox[OliveGreen]{}{\Bn_t} \ &= \  \eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ \eqnmarkbox[OliveGreen]{}{\Bn_{t-1}} \ + \ 
  \eqnmarkbox[xLSTMBlue]{}{\Ri_t} \ \eqnmarkbox[OliveGreen]{}{\Bk_t} & &  &\text{normalizer state} \\
\Bh_t  \ &= \ \eqnmarkbox[xLSTMBlue]{}{\bfo_t} \ \odot \ \tilde{\Bh}_t
\ , \qquad \qquad 
\tilde{\Bh}_t \ = \   \eqnmarkbox[OliveGreen]{}{\BC_t} \eqnmarkbox[OliveGreen]{}{\Bq_t} \ / \ 
  \max \left\{ \ABS{\eqnmarkbox[OliveGreen]{}{\Bn_t^\top} \eqnmarkbox[OliveGreen]{}{\Bq_t}}, 1 \right\} 
   &&&\text{hidden state} \\
\Bq_t \ &= \ \BW_q \ \Bx_t \ + \ \Bb_q  & &  &\text{query input} \\
\Bk_t \ &= \ \frac{1}{\sqrt{d}} \BW_k \ \Bx_t \ + \ \Bb_k  & &  &\text{key input} \\
\Bv_t \ &= \ \BW_v \ \Bx_t \ + \ \Bb_v  & &  &\text{value input} \\
\eqnmarkbox[xLSTMBlue]{}{\Ri_t} \ &= \ \eqnmarkbox[xLSTMRed]{}{\!\exp} \!  \! \left( \tilde{\Ri}_t  \right) \ , 
 \qquad \qquad \ \ \ \ \,
  \tilde{\Ri}_t \ = \ \Bw^\top_{\Ri} \ \Bx_t \ + \  b_{\Ri} \ \ \ 
  &&&\text{input gate} \\
\eqnmarkbox[xLSTMBlue]{}{\Rf_t} \ &= \ \sigma \!  \left(  \tilde{\Rf}_t \right) \ \text{OR} \ \eqnmarkbox[xLSTMRed]{}{\!\exp} \!  \! \left(  \tilde{\Rf}_t \right) , \ \ \: \!
\tilde{\Rf}_t \ = \ \Bw^\top_{\Rf} \ \Bx_t  \ + \
  b_{\Rf}
  &&& \text{forget gate} \\
\label{eq:mlstm_recurrent_end}
\eqnmarkbox[xLSTMBlue]{}{\bfo_t} \ &= \ \sigma \left( \tilde{\bfo}_t \right) \ , \qquad \qquad \quad \ \ \ \,
  \tilde{\bfo}_t  \ = \ \BW_{\bfo} \ \Bx_t \ + \
  \Bb_{\bfo}
  &&&\text{output gate} 
\end{aligned}$$

mLSTM can have multiple memory cells like the original LSTM. For mLSTM, multiple heads and multiple cells are equivalent as there is no memory mixing. In order to stabilize the exponential gates of mLSTM, we use the same stabilization techniques as for sLSTM (see Equation ). Since the mLSTM has no memory mixing, this recurrence can be reformulated in a parallel version. For more details we refer to Appendix .

## xLSTM Architecture

#### xLSTM Blocks.

An xLSTM block should non-linearly summarize the past in a high-dimensional space to better separate different histories or contexts. Separating histories is the prerequisite to correctly predict the next sequence element such as the next token. We resort to Cover’s Theorem , which states that in a higher dimensional space non-linearly embedded patterns can more likely be linearly separated than in the original space. We consider two residual block architectures: (i) A residual block with post up-projection (like Transformers), which non-linearly summarizes the past in the original space, then linearly maps into a high-dimensional space, applies a non-linear activation function, and linearly maps back to the original space; see left panel of Figure  and third column in Figure . A more detailed version is depicted in Figure  in the appendix. (ii) A residual block with pre up-projection (like State Space Models), which linearly maps to a high-dimensional space, non-linearly summarizes the past in the high-dimensional space and then linearly maps back to the original space. For an xLSTM block containing an sLSTM, we use the post up-projection block. For an xLSTM block containing an mLSTM, we use the pre up-projection block since the memory capacity becomes larger in the high-dimensional space. We refer to the left panel of Figure  and third column in Figure , or Figure  in the appendix for more details.

#### xLSTM Architecture. 

An xLSTM architecture is constructed by residually stacking building blocks . We rely on the most commonly used pre-LayerNorm  residual backbones as used in contemporary Large Language Models. See last column in Figure .

## Memory and Speed Considerations

Contrary to Transformers, xLSTM networks have a linear computation and a constant memory complexity with respect to the sequence length. Since the xLSTM memory is compressive, it is well suited for industrial applications and implementations on the edge.

The memory of mLSTM does not require parameters but is computationally expensive through its $d \times d$ matrix memory and $d \times d$ update. We trade off memory capacity against computational complexity. Nevertheless, the computations can be done in parallel on GPUs, therefore these computations have only a minor effect on the wall clock time.

While mLSTM is parallelizable analog to FlashAttention  or GLA , sLSTM is not parallelizable due to the memory mixing (hidden-hidden connections). However, we developed a fast CUDA implementation with GPU memory optimizations to the register level which is typically less than two times slower than mLSTM.

# Related Work

#### Linear Attention.

Several methods have been suggested to overcome the quadratic complexity in terms of context length of the Transformer and make attention linear in the context length. The Synthesizer learns synthetic attention weights without token–token interactions . Linformer realizes self-attention by a low-rank matrix and even linearly approximates it . Linear Transformer linearizes the attention mechanism . Performer linearly approximates the attention softmax by positive orthogonal random features approach . Attention has been replaced by fast long convolutions in the Structured Global Convolution (SGConv)  and the Hyena Hierarchy .

#### State Space Models.

Recently, State Space Models (SSMs) became very popular since they are linear in the context length and show promising performance compared to Transformers. One of the first proposed models was Structured State Space sequence model (S4) , followed by Diagonal State Space (DSS) model , Gated State Space (GSS) models , S5 model , Bidirectional Gated SSM (BiGS) , H3 model , and Mamba .

#### Recurrent Neural Networks.

Recurrent Neural Networks (RNNs) have been suggested to replace Transformer and attention due to their linearity in the context length. RNNs with Deep Linear Recurrent Units (LRUs) showed promising results for language modeling , as did Hierarchically Gated Linear RNN (HGRN) and HGRN2 . A well-known RNN approach to large language modeling is RWKV , showcasing competitive performance to Transformers.

#### Gating.

One of the key ideas of LSTM is gating, which was rediscovered and reinterpreted in many recent approaches. Gating was used in HGRN , HGRN2 , Gated Linear Attention (GLA) , Gated State Space (GSS) models , Bidirectional Gated SSM (BiGS) , Moving Average Equipped Gated Attention (MEGA) , RWKV , and Mamba .

#### Covariance Update Rule.

To enhance storage capacities, we equipped the mLSTM cell with a matrix memory with a covariance update rule. Other methods which build on such an update mechanism are Fast Weight Programmers , RWKV-5 and RWKV-6 , Retention , Linear Transformer , and HGRN2 .

#### Most Related.

Conceptually the closest models to xLSTM are Retention , RWKV , and HGRN2 . These models share the concepts matrix memory and/or gating. However, in contrast to the new sLSTM, these approaches do not allow memory mixing. Memory mixing enables to solve state tracking problems, and therefore LSTMs are more expressive than State Space Models (SSMs) and Transformers . State tracking is required to evaluate code or to track entities in a long narrative.

#### Residually Stacking Architectures.

Like almost all contemporary large deep learning models, xLSTM architectures are constructed by residually stacking building blocks . This construction enabled deep convolutional networks  and Transformers . Transformers are the ultimate force behind Large Language Models (LLMs) like GPT-3 , ChatGPT , GPT-4 , Megatron-LM , Gopher , ERNIE 3.0 Titan , GLaM  , Chinese M6 , mutilingual AlexaTM 20B , OPT , Chinchilla , BLOOM , GLM-130B , LaMDA , PaLM , Llama , Gemini .

# Experiments

In this section, we experimentally evaluate xLSTM and compare it to existing methods with a focus on language modeling. We investigate xLSTM’s specific capabilities on synthetic tasks in Section . In Section , we compare the validation set perplexity of various current language modeling methods that were trained on 15B tokens from SlimPajama . On the same dataset, we perform ablation studies for xLSTM. Then, we assess the scaling behavior of the different methods analogous to and . In Section , we conduct a more thorough language modeling experiment. We compare xLSTM and the best performing methods from Section  after being trained on 300B tokens from SlimPajama . First, we assess how well the methods perform in extrapolating to longer contexts, secondly we test the methods via validation perplexity and performance on downstream tasks , thirdly we evaluate the methods on 571 text domains of the PALOMA language benchmark dataset , fourthly we again assess the scaling behavior of the different methods, but now with 20 times more training data.

For all experiments, we use the notation xLSTM\[$a$:$b$\] for the ratio $a/b$ of mLSTM-based versus sLSTM-based xLSTM blocks. For example, xLSTM\[7:1\] means that out of eight blocks, seven are mLSTM-based blocks and one is an sLSTM-based block. For a common total block number of 48, this translates to 6 sLSTM-based blocks and 42 mLSTM-based blocks. Further, for all experiments, we use pre and post up-projection blocks for mLSTM and sLSTM, respectively.

## Synthetic Tasks and Long Range Arena

First, we test the effectiveness of xLSTM’s new exponential gating with memory mixing on formal languages . Then, we assess the effectiveness of xLSTM’s new matrix memory on the Multi-Query Associative Recall task . Finally, xLSTM’s performance at processing long sequences in the Long Range Arena is evaluated .

<figure>
<span class="image placeholder" data-original-image-src="figures/Chomsky_MainPaper.pdf" data-original-image-title="" width="\textwidth"></span>
<figcaption>Test of xLSTM’s exponential gating with memory mixing. Results are given by the scaled accuracy of different models at solving formal language tasks, of which some require state tracking. The different tasks are grouped by the Chomsky hierarchy. </figcaption>
</figure>

#### Test of xLSTM’s Exponential Gating with Memory Mixing.

We test xLSTM’s new exponential gating with memory mixing, which should enable it to solve state tracking problems . We implement and extend the formal language tasks from to enable multi-length training for length extrapolation. For a detailed description of all tasks and extended results see Appendix . We compare xLSTM to other methods including Transformers, State Space Models, and Recurrent Neural Networks. The accuracy of the tested methods is evaluated on those tokens relevant to the task. The accuracy is scaled between 0 (random) and 1 (perfect). We compare 2-block architectures of the following methods on these tasks: xLSTM\[0:1\] (i.e., only sLSTM), xLSTM\[1:0\] (i.e., only mLSTM), xLSTM\[1:1\], Llama, Mamba, RWKV, Retention, Hyena, LSTM, and LSTM in Transformer blocks (LSTM (Block)). The results of this experiment are shown in Figure . Models such as Transformers or State Space Models without memory mixing (no state tracking) cannot solve, e.g. regular grammars like the parity task. This result is in agreement with findings that Transformers and State Space models are fundamentally less powerful than RNNs .

#### Test of xLSTM’s Memory Capacities on Associative Recall Tasks.

In this experiment, we test xLSTM’s new matrix memory in terms of the memory capacity on the Multi-Query Associative Recall task : For each sequence, key-value pairs are randomly chosen from a large vocabulary, which must be memorized for later retrieval. To enhance the difficulty of the original task, we increase the number of key-value pairs up to 256 and extend the context length up to 2048. Thus, we have broader tests for the memory capacities of different models. We compare 2-block architectures of Llama, Mamba, RWKV-5, RWKV-6, xLSTM\[1:1\] and xLSTM\[1:0\]. The models are evaluated by the accuracy at recalling the pairs. Since Transformers (e.g. Llama) have a memory that is exponential in the coding dimension , they constitute the gold standard at this task. Results are shown in Figure . xLSTM\[1:1\] performs best among all non-Transformer models, also for small models. Interestingly, the sLSTM block does not diminish the memory capacity but rather leverages it, which becomes evident at the most difficult task with 256 key-value pairs. Additional results are presented in Appendix , where extrapolation analyses indicate that xLSTM’s enhanced memory capacities also allow for extrapolating to contexts that are longer than those seen during training.

<figure>
<span class="image placeholder" data-original-image-src="figures/MQAR_MainPaper.pdf" data-original-image-title="" width="\textwidth"></span>
<figcaption>Test of memory capacities of different models at the Multi-Query Associative Recall task with context length 2048. Each panel is dedicated to a different number of key-value pairs. The <span class="math inline">\(x\)</span>-axis displays the model size and the <span class="math inline">\(y\)</span>-axis the validation accuracy.  </figcaption>
</figure>

#### Test of xLSTM’s Long Context Capabilities on Long Range Arena.

To assess xLSTM’s performance on long sequences and large contexts, we compare different methods on the Long Range Arena . xLSTM demonstrates consistent strong performance on all of the tasks, suggesting that the xLSTM architecture is remarkably efficient in handling different aspects of long context problems. For more details, see Appendix .

## Method Comparison and Ablation Study

To address the main question of our paper, i.e. what can our new LSTM variants achieve when scaled up in language modelling, we train xLSTMs, Transformers, State Space Models, and other methods on 15B tokens from SlimPajama in the same auto-regressive setting. We compare the trained models on the validation set and perform ablation studies for the xLSTMs.

#### Comparing xLSTM to Other Methods.

For comparison, we train models on 15B tokens from SlimPajama . The trained models are evaluated by their perplexity on the validation set. We compare the following methods: xLSTM (our new method), GPT-3 (Transformer) , Llama (Transformer) , H3 (SSM) , Mamba (SSM) , RWKV-4 (RNN) , RWKV-5 (RNN) , RWKV-6 (RNN) , GLA (linear Transformer) , HGRN (RNN) , HGRN2 (RNN) . RetNet (linear Transformer) , Hyena (linear Transformer) , xLSTM\[1:0\], and xLSTM\[7:1\] (see Section ). The models were trained with mixed precision, for RWKV-5, RWKV-6, GLA, HGRN2, the mixed- precision training did not utilize the PyTorch automated mixed precision (see also Appendix Section ). We categorize the methods into (a) Transformers, (b) State Space Models (SSMs), and (c) Recurrent Neural Networks (RNNs) together with linear Transformers. Linear Transformers are linear methods that substitute the Transformer attention mechanism. The models match a GPT-3 model with 350M parameters in size, i.e. embedding dim 1024 and 24 residual blocks. Only GPT-3 uses shared weights for token and output embeddings, therefore has fewer parameters. The results in Table  show that xLSTM outperforms all existing methods in validation perplexity. For details see Appendix . Figure  shows the scaling behaviour for this experiment, indicating that xLSTM will also perform favorably for larger models.

#### Ablation Studies.

Table  and Figure  demonstrate that xLSTM achieves excellent results at language modeling when being trained on 15B tokens from SlimPajama. To ablate the changes from LSTM to xLSTM, we morph a vanilla LSTM architecture step-by-step into an xLSTM architecture. Firstly, we integrate LSTM layers into pre-LayerNorm residual backbones. Secondly, we extend this to a post up-projection block. Finally, we add exponential gating and matrix memory. The results are shown in Table  (top). The ablation studies attribute the strong performance improvement to both the exponential gating and the matrix memory. Additionally, due to the importance of gating in RNNs and State Space Models, we ablate different gating mechanisms. In Table  (bottom), we conclude that having each gate learnable and influenced by the input has an incremental positive effect. Additional studies on the individual backbone components are discussed in Appendix .

## xLSTM as Large Language Model

We culminate this study in large-scale language modeling experiments, testing the potential of xLSTM as an LLM. We therefore increase the amount of training data and train on 300B tokens from SlimPajama. The same number of tokens is used in, e.g., Mamba  and Griffin . We compare xLSTM to RWKV-4, Llama, and Mamba – one method from each respective method class in Section . We select RWKV-4 as RNN representative since for RWKV-5, RWKV-6 and HGRN2 a reasonable training precision setting has been found only after the training start of the 300B token experiments (see Appendix ). We train different model sizes (125M, 350M, 760M, 1.3B), test all models for length extrapolation capabilities and evaluate their performance on the validation set. We assess their performance on downstream tasks, test their performance in language modeling on 571 text domains of the PALOMA benchmark, and, finally, investigate their scaling law behavior.

#### Sequence Length Extrapolation.

Firstly, we test the sequence length extrapolation for 1.3B-sized, large models of xLSTM, RWKV-4, Llama, and Mamba. All models are trained on context length 2048, and then tested for context lengths up to 16384. See Figure  for the results. In contrast to other methods, xLSTM models maintain low perplexities for longer contexts.

<figure>
<span class="image placeholder" data-original-image-src="figures/plot_spaj300b_sequence_extrapolation.pdf" data-original-image-title="" width="115%"></span>
<figcaption>Sequence extrapolation in language modeling. This is a comparison of 1.3B-sized, large models of xLSTM, RWKV-4, Llama, and Mamba at next token prediction on the SlimPajama validation set after training on 300B tokens from SlimPajama. Models are trained with context length 2048 and then tested for context lengths up to 16384. <strong>Left:</strong> Token perplexities evaluated at different context lengths. In contrast to other methods, xLSTM models remain at low perplexities for longer contexts. <strong>Right:</strong> Prediction quality when extrapolating to long context sizes in terms of validation perplexity (PPL). xLSTM yields the best PPL values (best in bold, second best underlined).  </figcaption>
</figure>

#### Validation Perplexity and Downstream Tasks.

Secondly, for all model sizes, we evaluate the performance of xLSTM, RWKV-4, Llama, and Mamba models on the SlimPajama validation set for next token prediction and on downstream tasks that measure common sense reasoning. The third column of Table  lists the validation set perplexities of different methods. Both xLSTM\[1:0\] and xLSTM\[7:1\] are the best models for all model sizes with respect to the validation set perplexity. The other columns of Table  provide the performance on downstream tasks. In the vast majority of tasks and across all model sizes xLSTM is the best method — only on the ARC task Mamba is in some cases the best method. For details see Appendix .

#### Performance on PALOMA Language Tasks.

Thirdly, for all model sizes, we test the next token prediction performance of xLSTM, RWKV-4, Llama, and Mamba models on PALOMA language tasks . We measure the performance by the perplexity for next token prediction on 571 text domains, which range from nytimes.com to r/depression on Reddit. Table  shows token prediction perplexity grouped into language modeling (first seven columns) and fine-grained domain benchmarks (last 5 columns). xLSTM\[1:0\] performs better than xLSTM\[7:1\] on these language tasks. xLSTM\[1:0\] has in 568 out of 571 (99.5%) text domains a lower perplexity than Mamba, in 486 out of 571 (85.1%) a lower perplexity than Llama, in 570 out of 571 (99.8%) a lower perplexity than RWKV-4. For details see Appendix .

#### Scaling Laws.

Fourthly, we assess the power-law scaling behavior, which allows to extrapolate the performance to larger model sizes . Figure  presents the scaling behavior. All models share a similar scaling behavior but with different offsets. RWKV-4 performs worst, followed by Llama and Mamba. xLSTM is better than Mamba with a similar margin to Mamba as Mamba has to Llama. The scaling behavior indicates that for larger models xLSTM will continue to perform favourable compared to Transformers and State-Space models.

<figure>
<span class="image placeholder" data-original-image-src="figures/plot_spaj300b_xlstm_scaling_laws.pdf" data-original-image-title="" width="100%"></span>
<figcaption>Scaling laws. Next token prediction perplexity of xLSTM, RWKV-4, Llama, and Mamba on the SlimPajama validation set when trained on 300B tokens from SlimPajama. Model sizes are 125M, 350M, 760M, and 1.3B. Best models for each model class, see Table <span class="math inline">\(\ref{tab:spaj15b_model_results}\)</span>, were selected. The scaling laws indicate that for larger models xLSTM will perform well too. </figcaption>
</figure>

**Generation Times and Maximal Throughput.** Finally, we measure the text generation time in Figure  and the maximal throughput in Figure  (left) for our xLSTM variants at 1.3B scale. We compare against similar sized Mamba, Llama and RWKV implementions from HuggingFace, including a static key-value cache for the Llama model. At the time of the experiments, both full cache compilation of the Transformer Model and compilation of the Mamba model with `torch.compile` did not work. For the text generation experiments all of the models are tested at batch size 1 and pre-fill 16. This pre-fill should be maximally favorable for the Transformer. Figure  shows the linear scaling of the xLSTM and the other recurrent models Mamba and RWKV-4 compared to the quadratic scaling of Llama. For the decoding throughput we measure different batch sizes and prefill for the Llama model. Figure  (right) shows that xLSTM can use much higher batch sizes than Llama due to its constant memory and thus achieves the highest throughput.

<figure>
<span class="image placeholder" data-original-image-src="figures/inference_generation_time_v4b.pdf" data-original-image-title="" width="\textwidth"></span>
<span class="image placeholder" data-original-image-src="figures/inference_decoding_throughput_bar_v5b.pdf" data-original-image-title="" width="\textwidth"></span>
<figcaption>Inference Generative Speed. <strong>Left:</strong> Generation times of different 1.3B models for a pre-fill context of 16 tokens (to mitigate cache initialization). The recurrent models (xLSTM[1:0], xLSTM[7:1], Mamba and RWKV-4) show linear behavior, whereas the Transformer (Llama) inference/decoding time is quadratic in sequence length.  <strong>Right:</strong> Token throughput for different batch sizes on a A100-80GB GPU for 1.3B sized models. Note that the Transformer / Llama model goes out of memory (OOM) already for small batch sizes, whereas xLSTM and Mamba can sustain very large batch sizes. xLSTM[1:0] consistently outperforms Mamba in throughput. </figcaption>
</figure>

# Limitations

\(i\) In contrast to mLSTM, memory mixing of the sLSTM prohibits parallelizable operations, and therefore does not allow a fast parallel implementation. Nevertheless, we developed a fast CUDA kernel for sLSTM, which is currently less than two times slower than our parallel mLSTM implementation. (ii) The CUDA kernels for mLSTM are not optimized, and therefore the current implementation is about 4 times slower than FlashAttention or the scan used in Mamba. Faster CUDA kernels could be obtained in the vein of FlashAttention. (iii) The matrix memory of mLSTM has high computation complexity since $d \times d$ matrices must be processed. Still, the memory update and retrieval does not use parameters and can be parallelized using standard matrix operations, therefore the wall clock time overhead due to the complex memory is minor. (iv) The initialization of the forget gates must be chosen carefully. (v) Since the matrix memory is independent of the sequence length, increasing the sequence length might overload the memory for longer context sizes. Still, this does not appear to be a limitation for contexts up to 16k, see Section . (vi) Due to the expensive computational load for large language experiments, we did neither fully optimize the architecture nor the hyperparameters, especially for larger xLSTM architectures. We anticipate that an extensive optimization process is needed for xLSTM to reach its full potential.

# Conclusion

We have partly answered our simple question: How far do we get in language modeling when scaling LSTM to billions of parameters? So far, we can answer: “At least as far as current technologies like Transformers or State Space Models”. We have enhanced LSTM to xLSTM by exponential gating with memory mixing and a new memory structure. xLSTM models perform favorably on language modeling when compared to state-of-the-art methods like Transformers and State Space Models. The scaling laws indicate that larger xLSTM models will be serious competitors to current Large Language Models that are built with the Transformer technology. xLSTM has the potential to considerably impact other fields like Reinforcement Learning, Time Series Prediction, or the modeling of physical systems.

# Acknowledgements

We thank Sebastian Lehner, Daniel Klotz, Thomas Adler, Matthias Dellago, Gerald Gutenbrunner, Fabian Paischer, Vihang Patil, Niklas Schmidinger, Benedikt Alkin, Kajetan Schweighofer, Anna Zimmel, Lukas Aichberger, Lukas Hauzenberger, Bernhard Schäfl and Johannes Lehner for helpful discussions and feedback.
