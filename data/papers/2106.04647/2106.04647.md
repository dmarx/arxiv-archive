---
abstract: |
  Adapting large-scale pretrained language models to downstream tasks via fine-tuning is the standard method for achieving state-of-the-art performance on NLP benchmarks. However, fine-tuning all weights of models with millions or billions of parameters is sample-inefficient, unstable in low-resource settings, and wasteful as it requires storing a separate copy of the model for each task. Recent work has developed *parameter-efficient* fine-tuning methods, but these approaches either still require a relatively large number of parameters or underperform standard fine-tuning. In this work, we propose <span class="smallcaps">Compacter</span>, a method for fine-tuning large-scale language models with a better trade-off between task performance and the number of trainable parameters than prior work. <span class="smallcaps">Compacter</span> accomplishes this by building on top of ideas from adapters, low-rank optimization, and parameterized hypercomplex multiplication layers.

  Specifically, <span class="smallcaps">Compacter</span> inserts task-specific weight matrices into a pretrained model’s weights, which are computed efficiently as a sum of Kronecker products between shared “slow” weights and “fast” rank-one matrices defined per <span class="smallcaps">Compacter</span> layer. By only training $0.047\%$ of a pretrained model’s parameters, <span class="smallcaps">Compacter</span> performs on par with standard fine-tuning on GLUE and outperforms standard fine-tuning on SuperGLUE and low-resource settings. Our code is publicly available at <https://github.com/rabeehk/compacter>.
author:
- |
  Rabeeh Karimi Mahabadi  
  EPFL University, Idiap Research Institute  
  `rabeeh.karimi@idiap.ch`  
  James Henderson  
  Idiap Research Institute  
  `james.henderson@idiap.ch`  
  Sebastian Ruder  
  DeepMind  
  `ruder@google.com`
bibliography:
- ref.bib
citation-style: ieee
header-includes:
- 
- 
link-citations: true
reference-section-title: References
title: |
  <span class="smallcaps">Compacter</span>:  
  Efficient Low-Rank Hypercomplex Adapter Layers
---





# Introduction

<figure>
<p> <span class="image placeholder" data-original-image-src="figures/comparison_plot.pdf" data-original-image-title="" width="100%">image</span></p>
<p></p>
<p> <span class="image placeholder" data-original-image-src="figures/our_method_3.pdf" data-original-image-title="" width="100%">image</span> </p>
<p></p>
<figcaption> Left: Adapter integration in a pretrained transformer model. Right: Adapter architecture. Following <span class="citation" data-cites="houlsby2019parameter"></span>, we include adapters after the attention and feed-forward modules. During training, we only update layer normalizations and adapters (shown in yellow), while the pretrained model is fixed.</figcaption>
</figure>

State-of-the-art pretrained language models (PLMs) in natural language processing (NLP) have used heavily over-parameterized representations consisting of hundreds of millions or billions of parameters to achieve success on a wide range of  

<div class="epigraph">

With four parameters I can fit an elephant, and with five I can make him wiggle his trunk.

John von Neumann

</div>

NLP benchmarks . These models are generally applied to downstream tasks via fine-tuning , which requires updating *all* parameters and storing one copy of the fine-tuned model per task. This causes substantial storage and deployment costs and hinders the applicability of large-scale PLMs to real-world applications. Additionally, fine-tuning of over-parameterized models on low-resource datasets has been shown to be subject to instabilities and may lead to poor performance .

Inspired by John von Neumann’s quotation, we ask, given that we have already learned general-purpose language representations via a PLM (i.e. we have fit our elephant), how many more parameters do we need to reach state-of-the-art performance on standard NLP tasks. Specifically, we aim to develop practical, memory-efficient methods that train a minimum set of parameters while achieving performance on par or better than full fine-tuning for state-of-the-art NLP models.

Recent literature has introduced *parameter-efficient* fine-tuning methods. These approaches generally keep the pretrained model’s parameters fixed and introduce a set of trainable parameters per task, trading off the number of trainable parameters with task performance. At one end of the spectrum, *prompts*, i.e. natural language descriptions of a task, together with demonstrations have been used to achieve reasonable performance *without any* parameter updates on some benchmarks but their performance generally lags behind fine-tuned models. They also require huge models to work well but choosing good prompts becomes harder with larger model sizes . *Soft prompt* methods treat prompts as trainable continuous parameters, which are prepended to the inputs at the input layer or intermediate layers . Such methods, however, often require large models to achieve good performance and are very sensitive to initialization and unstable during training.

The theoretically motivated *low-rank* methods train a small number of parameters that lie in a low-dimensional subspace using random projections . However, storing the random projection matrices causes substantial memory overhead and leads to slow training times. At the other end of the spectrum, *adapter* methods that insert trainable transformations at different layers of the pretrained model require more parameters than the aforementioned approaches but are more memory-efficient and obtain performance comparable to full fine-tuning .

In this work, we propose <span class="smallcaps">Compacter</span>, a method for fine-tuning large-scale language models with an excellent trade-off between the number of trainable parameters, task performance, and memory footprint, compared to existing methods (see Figure ). <span class="smallcaps">Compacter</span> builds on ideas from adapters , low-rank methods , as well as recent hypercomplex multiplication layers . Similar to adapters, <span class="smallcaps">Compacter</span> inserts task-specific weight matrices into a pretrained model’s weights. Each <span class="smallcaps">Compacter</span> weight matrix is computed as the sum of Kronecker products between shared “slow” weights and “fast” rank-one matrices defined per <span class="smallcaps">Compacter</span> layer (see Figure ). As a result, <span class="smallcaps">Compacter</span> achieves a parameter complexity of $\mathcal{O}(k+d)$ compared to $\mathcal{O}(kd)$ for regular adapters, where the adapters are of size $k\!{\times}\! d$. In practice, <span class="smallcaps">Compacter</span> trains $0.047\%$ of a PLM’s parameters. On the standard GLUE  and SuperGLUE  benchmarks, <span class="smallcaps">Compacter</span> outperforms other parameter-efficient fine-tuning methods and obtains performance on par or better than full fine-tuning. On low-resource settings, <span class="smallcaps">Compacter</span> outperforms standard fine-tuning.

In summary, we make the following contributions: **1)** We propose <span class="smallcaps">Compacter</span>(**Compact** Adapt**er**) layers, a parameter-efficient method to adapt large-scale language models. **2)** We show that <span class="smallcaps">Compacter</span> obtains strong empirical performance on GLUE and SuperGLUE. **3)** We demonstrate that <span class="smallcaps">Compacter</span> outperforms fine-tuning in low-resource settings. **4)** We provide a parameter complexity analysis of <span class="smallcaps">Compacter</span>, showing that it requires dramatically fewer parameters than adapters and fine-tuning. **5)** We provide a systematic evaluation of recent parameter-efficient fine-tuning methods in terms of training time and memory consumption. We release our code to facilitate future work.

# Background

We start by introducing the required background on the Kronecker product and adapter layers .

## Kronecker Product

The Kronecker product between matrix $\bm{A}\in \mathbb{R}^{m\times f}$ and $\bm{B} \in \mathbb{R}^{p\times q}$, denoted by $\bm{A}\otimes \bm{B} \in \mathbb{R}^{mp\times fq}$, is mathematically defined as: $$\bm{A}\otimes\bm{B} =   \begin{pmatrix}
a_{11}\bm{B}  & \cdots & a_{1f}\bm{B} \\
\vdots  & \ddots & \vdots  \\
a_{m1}\bm{B}  & \cdots & a_{mf}\bm{B} 
\end{pmatrix},$$ where $a_{ij}$ shows the element in the $i^\text{th}$ row and $j^\text{th}$ column of $\bm{A}$.

## Adapter Layers

Recent work has shown that fine-tuning *all* parameters of a language model can lead to a sub-optimal solution, particularly for low-resource datasets . As an alternative, and propose to transfer a model to new tasks by inserting small task-specific modules called *adapter layers* within the layers of a pretrained model, as depicted in Figure . They then only train adapters and layer normalizations, while the remaining parameters of the pretrained model remain fixed. This approach allows pretrained language models to efficiently adapt to new tasks.

Each layer of a transformer model is composed of two primary modules: a) an attention block, and b) a feed-forward block. Both modules are followed by a skip connection. As shown in Figure ,  suggest to insert an adapter layer after each of these blocks before the skip connection.

Adapters are bottleneck architectures. By keeping the output dimension similar to their input, they cause no change to the structure or parameters of the original model. The adapter layer $A^l$ for layer $l$ consists of a down-projection, $\bm{D^l}\in\mathbb{R}^{k\times d}$, GeLU non-linearity , and up-projection $\bm{U^l} \in\mathbb{R}^{d \times k}$, where $k$ is the input dimension, and $d$ is the bottleneck dimension for the adapter layer. Adapters are defined as: $$\begin{aligned}
A^l(\bm{x}) = \bm{U^l}(\text{GeLU}(\bm{D^l}(\bm{x}))) + \bm{x}, \label{eq:adapters}
\end{aligned}$$ where $\bm{x}$ is the input hidden state.

# Method

In this section, we present <span class="smallcaps">Compacter</span>, a compact and efficient way to adapt large-scale PLMs.

**Problem formulation** $\:$ We consider the general problem of fine-tuning large-scale language models, where we are given the training data $\mathcal{D}= \{(\bm{x^i}, y^i)\}_{i=1}^{P}$ with $P$ samples. We assume we are also given a large-scale pretrained language model $f_{\bm{\theta}}(.)$ parameterized by $\bm{\theta}$ that computes the output for input $\bm{x^i}$. Our goal is to fine-tune $f_{\bm{\theta}}(.)$ efficiently to enable the model to adapt to new tasks.

<figure id="fig:compactformer">
<p> <span class="image placeholder" data-original-image-src="figures/compacter_phm_version_2.pdf" data-original-image-title="" width="100%">image</span></p>
<figcaption>Illustration of generating weights of two different <span class="smallcaps">Compacter</span> layers: <span class="math inline">\(\bm{W_1} \in \mathbb{R}^{d \times k}\)</span> (first row) and <span class="math inline">\(\bm{W_2}  \in \mathbb{R}^{d \times k}\)</span> (second row). We generate <span class="math inline">\(\bm{W_1}\)</span> and <span class="math inline">\(\bm{W_2}\)</span> using <span class="math inline">\(\bm{W_j} = \sum_{i=1}^n \bm{A_i} \otimes \bm{{B_i}^j} = \sum_{i=1}^n \bm{A_i} \otimes (\bm{{s_i}^j}{\bm{{t_i}^j}}^\top)\)</span> <span class="math inline">\(\eqref{eq:our_method}\)</span>, by computing the sum of Kronecker products of <em>shared</em> matrices <span class="math inline">\(\bm{A_i}\)</span> and <em>adapter-specific</em> matrices <span class="math inline">\(\bm{B_i^j}\)</span>, with <span class="math inline">\(i\in\{1, \dots, n\}\)</span> and adapter index <span class="math inline">\(j\in\{1, 2\}\)</span>. We generate each <span class="math inline">\(\bm{B_i^j}\)</span> by multiplying independent rank one weights. In this example <span class="math inline">\(n=2\)</span>, <span class="math inline">\(d=6\)</span>, and <span class="math inline">\(k=8\)</span>. </figcaption>
</figure>

## Compact and Efficient Adapter Layers

In this section, we introduce an efficient version of adapter layers, building on top of recent advances in *parameterized hypercomplex multiplication layers* (PHM) . To the best of our knowledge, we are the first to exploit PHM layers for efficient fine-tuning of large-scale transformer models. The PHM layer has a similar form as a fully-connected layer, which converts an input $\bm{x}\in\mathbb{R}^k$ to an output $\bm{y}\in\mathbb{R}^d$: $$\begin{aligned}
    \bm{y} =  \bm{W}\bm{x}+\bm{b}, \label{eq:phm}  %\text{PHM}(\bm{x}) =
\end{aligned}$$ where $\bm{W}\in\mathbb{R}^{k\times d}$. The key difference is that in a PHM layer, $\bm{W}$ is learned as a sum of Kronecker products. Assume that $k$ and $d$ are both divisible by a user-defined hyperparameter $n \in \mathbb{Z}_{>0}$. Then, the matrix $\bm{W}$ in is computed as the sum of $n$ Kronecker products as follows: $$\begin{aligned}
\bm{W} = \sum_{i=1}^n \bm{A_i} \otimes \bm{B_i}, 
\label{eq:phm-params} 
\end{aligned}$$ where $\bm{A_i}\in\mathbb{R}^{n\times n}$ and $\bm{B_i}\in\mathbb{R}^{\frac{k}{n}\times \frac{d}{n}}$. The PHM layer has a parameter complexity of $\mathcal{O}(\frac{kd}{n})$, reducing parameters by at most $\frac{1}{n}$ (see ).

## Beyond Hypercomplex Adapters

Prior work indicates that some of the information captured in pretrained models can be ignored for transfer . Similarly, redundancies have been observed in the information captured by adapters, with adapters in lower layers being less important . In addition, sharing adapters across layers leads to a comparatively small drop of performance for some tasks . Motivated by these insights, we propose the following two extensions to make hypercomplex adapters more efficient.

**Sharing information across adapters** $\:$ Sharing all adapter parameters across layers is overall too restrictive and is not able to perform on par with fine-tuning or using regular adapters ; however, our decomposition of adapters into $\bm{A_i}$ and $\bm{B_i}$ matrices as in Eq.  allows us to be more flexible. Consequently, we divide our adaptation weights into *shared* parameters that capture general information useful for adapting to the target task and *adapter-specific* parameters that focus on capturing information relevant for adapting each individual layer. Specifically, we define $\bm{A_i}$ as shared parameters that are common across all adapter layers while $\bm{B_i}$ are adapter-specific parameters.

**Low-rank parameterization** $\:$ Low-rank methods have demonstrated that strong performance can be achieved by optimizing a task in a low-rank subspace. Similarly, we hypothesize that a model can also be effectively adapted by learning transformations in a low-rank subspace. To this end, we propose to parameterize $\bm{B_i}\in\mathbb{R}^{\frac{k}{n}\times \frac{d}{n}}$ as a low-rank matrix, which is the product of two low-rank weights $\bm{s_i} \in \mathbb{R}^{\frac{k}{n}\times r}$ and $\bm{t_i}\in \mathbb{R}^{r \times {\frac{d}{n}}}$, where $r$ is the rank of the matrix.[^1] Putting both extensions together, we propose the *low-rank* parameterized hypercomplex multiplication layer (LPHM): $$\begin{aligned}
\bm{W} = \sum_{i=1}^n \bm{A_i} \otimes \bm{B_i} = \sum_{i=1}^n \bm{A_i} \otimes (\bm{s_i}\bm{t_i}^\top).
\label{eq:our_method}
\end{aligned}$$ In general, we set $r=1$ so that $\bm{B_i}$ is a rank-one matrix. Depending on the complexity of the target task, $r$ can be set to a higher value.[^2] Figure  illustrates our method. Overall, the LPHM layer reduces complexity further to $\mathcal{O}(k+d)$ (see ). The LPHM layer can also be seen as leveraging “slow” weights $\bm{A_i}$ that are shared across adapters and capture general information and “fast” weights $\bm{B_i}$ that learn adapter-specific information for adaptation of each individual layer .

**<span class="smallcaps">Compacter</span>** $\:$ Based on the above formulation, we introduce <span class="smallcaps">Compacter</span> layers, which replace the down-projection and up-projection layers in adapters as follows: $$\begin{aligned}
A^l(\bm{x}) =\text{LPHM}^{U^l}(\text{GeLU}(\text{LPHM}^{D^l}(\bm{x}))) + \bm{x}, \nonumber
% {LN}^{l}\left(\right)
\end{aligned}$$ where the up-projection weights $\text{LPHM}^{U^l}$ are computed as in , replacing the layer $U^l$ in . Similarly, down-projection weights $\text{LPHM}^{D^l}$ replace the layer $D^l$. While the two adapters in each layer of a transformer have their own $\bm{s_i}$ and $\bm{t_i}$ rank-one weights, we share the $\bm{A_i}$ across all layers and positions of the adapter layers.

# Parameter Efficiency

In this section, we compare the number of parameters of <span class="smallcaps">Compacter</span> with adapters.

**Adapters parameters** $\:$ In the standard setting, two adapters are added per layer of a transformer model . Each adapter layer consists of $2kd$ parameters for the down and up-projection matrices ($\bm{U^l}$, $\bm{D^l}$) respectively where $k$ is the size of the input dimension and $d$ is the adapter’s bottleneck dimension. The total number of parameters for adapters for a transformer model with $L$ layers of both an encoder and a decoder is, therefore, $2L(2kd)$, which scales linearly with all three variables.

**<span class="smallcaps">PHM-Adapter</span> parameters** $\:$ In the conventional PHM layer , as depicted in Eq. , parameters of $\bm{A_i}\in\mathbb{R}^{n\times n}$ and $\bm{B_i}\in\mathbb{R}^{\frac{k}{n}\times \frac{d}{n}}$ define the degree of freedom for $\bm{W}$ as $n(\frac{kd}{n^2}+n^2)=\frac{kd}{n}+n^3$. With the mild condition that $kd > n^4$, then $\frac{kd}{n}$ dominates and the overall parameter size of the PHM layer in is $\mathcal{O}(\frac{kd}{n})$. This condition is satisfied for typical values for adapters, PHM layers, and large-scale PLMs such as T5-large, with hidden size $k = 1024$, adapter hidden size $d\in\{24, 32, 48, 96\}$, and $n = 2,4,8,12$. Hence, the PHM layer offers a parameter reduction of almost $\frac{1}{n}$ compared to standard fully-connected layers, which are $\mathcal{O}(kd)$.[^3]

Similarly, employing PHM layers for modeling down and up-projection matrices offers a parameter reduction of almost $\frac{1}{n}$. Each adapter with a PHM layer has in total $2(\frac{kd}{n}+n^3)$ parameters. For a Transformer model with $L$ layers, the total number of parameters of <span class="smallcaps">PHM-Adapter</span> is $4L(\frac{kd}{n}+n^3)$.

**<span class="smallcaps">Compacter</span> parameters** $\:$ <span class="smallcaps">Compacter</span> shares the trained weight matrices $\{\bm{A_i}\}_{i=1}^n$ in  consisting of $n^3$ parameters across all layers. <span class="smallcaps">Compacter</span> also has two rank-one weights for each adapter, $\bm{s_i},\bm{t_i}$ in  consisting of $\frac{k}{n}+\frac{d}{n}$ parameters, resulting in a total of $2n(\frac{k}{n}+\frac{d}{n})$ parameters for down and up-projection weights. Therefore, the total number of parameters of <span class="smallcaps">Compacter</span> is $4L(k+d) + n^3$ for a transformer with $L$ layers in the encoder and decoder.

In settings with a large number of layers, the dominant term is $4L(k+d)$. Therefore, with a mild condition that $4L(k+d)>n^3$, <span class="smallcaps">Compacter</span> has a complexity of $\mathcal{O}(k+d)$, which is far more efficient compared to adapters’ $\mathcal{O}(kd)$ and <span class="smallcaps">PHM-Adapter</span>’s $\mathcal{O}(\frac{kd}{n})$ complexity respectively. In settings where $n$ is large, the number of parameters for shared weight matrices $\{\bm{A_i}\}_{i=1}^n$ for all layers remain constant in <span class="smallcaps">Compacter</span> with a total of $n^3$ parameters while this scales linearly with the number of layers $L$ for PHM and adapter layers. As an example, in the T5<sub>BASE</sub> model with 222M parameters , <span class="smallcaps">Compacter</span> only learns $0.047\%$ of the parameters, and maintains comparable performance to *full fine-tuning*.

# Experiments

**Datasets** $\:$ Following , we evaluate the performance of the methods on the GLUE  and SUPERGLUE  benchmarks. These benchmarks cover multiple tasks of paraphrase detection (MRPC, QQP), sentiment classification (SST-2), natural language inference (MNLI, RTE, QNLI, CB), linguistic acceptability (CoLA), question-answering (MultiRC, ReCoRD, BoolQ), word sense disambiguation (WiC), and sentence completion (COPA).[^4] As the original test sets are not publicly available, we follow  and split off 1k samples from the training set that we use for validation, while we use the original validation data as the test set. For datasets with fewer than 10k samples (RTE, MRPC, STS-B, CoLA, COPA, WiC, CB, BoolQ, MultiRC), we divide the original validation set in half, using one half for validation and the other for testing.

**Experimental details** $\:$ We use the state-of-the-art encoder-decoder T5 model  as the underlying model for all methods in our experiments. For computational efficiency, we report all results on T5<sub>BASE</sub> models (12 encoder and decoder layers and 222M parameters). We use its HuggingFace PyTorch implementation . We fine-tune all methods for 3 epochs on large datasets and 20 epochs for low-resource datasets of <span class="smallcaps">GLUE</span>(MRPC, CoLA, STS-B, RTE, BoolQ, CB, COPA, WiC) to allow the models to converge . For all adapter-based methods, we experiment with adapters of bottleneck size of $\{96, 48, 24\}$. We save a checkpoint every epoch for all models and report the results for the hyper-parameters performing the best on the validation set for each task. For the PHM layers, we use the PyTorch implementation of . We include low-level details in Appendix . For our methods, we experiment with $n=\{4, 8, 12\}$ and report the model performing the best. We include the results for all values of $n$ in Appendix .

Following , we freeze the output layer of the pretrained model for all tasks across all methods.[^5] We show the results with fine-tuning the output layer in Appendix . Following , we update the layer normalization parameters for all methods where applicable.[^6]

## Baselines

We compare against several recently proposed *parameter-efficient* fine-tuning methods:

**T5<sub>BASE</sub>** $\:$ We compare our method to the standard practice of fine-tuning T5, where we fine-tune all parameters of the model on each individual task.

**<span class="smallcaps">Adapter</span>** $\:$ We compare to a strong adapter baseline , which adds adapters for each task after the feed-forward and attention modules in each transformer block of T5.

**<span class="smallcaps">Pfeiffer-Adapter</span>** $\:$ propose a more efficient adapter variant, which keeps only one of the adapters in each layer for better training efficiency. We experimented with keeping either adapter and found keeping the adapter after the self-attention module in each layer to perform the best.

**<span class="smallcaps">Adapter-LowRank</span>** $\:$ We parameterize each adapter’s weight as a product of two rank-one weights.

**<span class="smallcaps">Prompt Tuning</span>** $\:$ Prompt tuning  is the successor variant of , which prepends a randomly initialized continuous prompt to the input (<span class="smallcaps">Prompt Tuning-R</span>). We also compare to a variant, which initializes prompts using token embeddings of the pretrained language model’s vocabulary (<span class="smallcaps">Prompt Tuning-T</span>) .

**<span class="smallcaps">Intrinsic-SAID</span>** $\:$ The Structure Aware Intrinsic Dimension fine-tunes the model by reparameterizing the parameters in a lower-dimensional subspace $\bm{\theta^{d^{\prime}}}$ ($d^{\prime} \ll D$): $\bm{\theta_i^D} = \bm{\theta^D_{i,0}} + \lambda_i \bm{P} \bm{\theta^{d^{\prime}-m}_i}$ where parameter $\bm{\theta^D_{i,0}}$ are the pretrained model’s parameters and $\bm{P} \in \mathbb{R}^{d^\prime-m}\to \mathbb{R}^D$ is a random linear projection via the Fastfood transform . They then consider the total number of weight matrices in the PLM, $m$, and attribute a weight to each of them, resulting in $\bm{\lambda} \in\mathbb{R}^m$ in total by trading $m$ parameters from the low dimensional space $\bm{\theta^{d^{\prime}}} \in \mathbb{R}^{d^{\prime}}$. Then, the total trainable parameters are $\bm{\theta^{d^{\prime}-m}} \in \mathbb{R}^{d^{\prime} - m}$ and $\bm{\lambda}$.

**<span class="smallcaps">AdapterDrop</span>** $\:$ We apply the method of , which drops the adapters from lower transformer layers for a better training efficiency to T5 with <span class="smallcaps">Adapter</span>. Consequently, we drop adapters from the first five layers of both the encoder and the decoder in T5<sub>BASE</sub>.

**<span class="smallcaps">BitFit</span>** $\:$   propose to freeze the weights and only train the biases. By not storing intermediate activations, this method enables substantial memory savings. study a similar method for PLMs that fine-tunes only the biases and the final output layer.[^7]

## Our Methods

**<span class="smallcaps">PHM-Adapter</span>** $\:$ We learn the weights of adapters using PHM layers as in . To our knowledge, we are the first who exploit the idea of PHM  for efficient *fine-tuning* of large-scale language models.

**<span class="smallcaps">Compacter</span>** $\:$ We learn adapter weights using LPHM layers as described in . We also explore a variant where we only keep the <span class="smallcaps">Compacter</span> layer after the feed-forward layer in each transformer block (<span class="smallcaps">Compacter</span>`++`).[^8]

## Results on the GLUE Benchmark

Table  shows the results on <span class="smallcaps">GLUE</span> with T5<sub>BASE</sub>(see Appendix for results on T5<sub>SMALL</sub>). <span class="smallcaps">Compacter</span> and <span class="smallcaps">Compacter</span>`++` outperform all previous parameter-efficient methods and perform on par with full fine-tuning while only training 0.07% and 0.047% of parameters respectively. We now discuss the different methods in detail.

**Adapter-based methods** $\:$ For <span class="smallcaps">Adapter</span>, not fine-tuning the classifier hurts the performance substantially (85.78 versus 86.48; cf. Appendix ). <span class="smallcaps">Pfeiffer-Adapter</span>, which adds adapters only after the self-attention module outperforms the standard <span class="smallcaps">Adapter</span> while being more parameter-efficient. <span class="smallcaps">AdapterDrop</span> obtains lower performance than fine-tuning, demonstrating that adapting the lower layers of an encoder-decoder T5 model is important for its performance. Additionally, <span class="smallcaps">Adapter-LowRank</span> is not expressive enough to perform well on this benchmark.

**Prompt tuning and BitFit** $\:$ For <span class="smallcaps">Prompt Tuning</span>, we observe high sensitivity to initialization and learning rate, as also confirmed in . We experimented with multiple random seeds but performance lags behind fine-tuning substantially, in particular on low-resource datasets. This can be explained by the low flexibility of such methods as all the information needs to be contained in the prefixes. As a result, the method only allows limited interaction with the rest of the model and good performance requires very large models . In addition, increasing the sequence length leads to memory overhead (see ) and the number of prompt tokens is limited by the number of tokens that can fit in the model’s maximum input length, which makes such methods less flexible and unsuitable for dealing with large contexts. Similarly, <span class="smallcaps">BitFit</span> performs worse than fine-tuning, especially on low-resource datasets.

**Intrinsic-SAID** $\:$ Interestingly, the average performance of <span class="smallcaps">Intrinsic-SAID</span>, which fine-tunes only 0.009% of a model’s parameters is only 1.05 points below the fine-tuning baseline. However, this method has two practical drawbacks: a) storing the random projection matrices results in a substantial memory overhead; b) it is very slow to train (see ). Despite this, <span class="smallcaps">Intrinsic-SAID</span> provides insights regarding the effectiveness of low-rank optimization of pretrained language models , which motivates the development of parameter-efficient methods such as <span class="smallcaps">Compacter</span>.

**<span class="smallcaps">Compacter</span>** $\:$ For our proposed methods, we observe fine-tuning the output layer for both <span class="smallcaps">PHM-Adapter</span> and <span class="smallcaps">Compacter</span>`++` does not provide much performance difference (see Appendix ). <span class="smallcaps">PHM-Adapter</span> reduces the parameters of <span class="smallcaps">Adapter</span> from 0.83% to 0.179% (with $n=12$), being 4.64$\times$ more parameter-efficient. <span class="smallcaps">Compacter</span> reduces the number of parameters to the remarkable rate of 0.073% while obtaining comparable results to full fine-tuning. By removing the <span class="smallcaps">Compacter</span> layer after self-attention, <span class="smallcaps">Compacter</span>`++` obtains similar performance, while reducing the parameters to 0.047%. Adaptation without updating the layer normalization can be a promising direction to reduce the parameters further, for instance by building on recent advances in normalization-free models , which we leave to future work.

## Results on the <span class="smallcaps">SuperGLUE</span> Benchmark

Table shows the performance of the methods on <span class="smallcaps">SuperGLUE</span>. We include the results for all values of $n$ in Appendix . We observe a similar pattern as on <span class="smallcaps">GLUE</span> in Table . <span class="smallcaps">Compacter</span> and <span class="smallcaps">Compacter</span>`++` perform substantially better compared to other parameter-efficient fine-tuning methods and even outperform full fine-tuning while only training 0.073% and 0.048% of the parameters.

## Efficiency Evaluation

In this section, we compare the efficiency of our proposed methods with various recently proposed parameter-compact fine-tuning methods under the same computation budget. To this end, we train all methods for 1 epoch on the MNLI dataset. For each method, we select the largest batch size that fits a fixed budget of the GPU memory (24 GB). For all adapter-based methods, we fix the adapter size to 24. For <span class="smallcaps">Prompt Tuning</span>, we set the number of prefix tokens to 100. For <span class="smallcaps">Intrinsic-SAID</span>, we set $d^{\prime}=1400$. Finally, we set $n=4$. In Table , we report the percentage of trained parameters per task, training time per epoch, and memory usage of each method. Moreover, Figure shows the trade-off between quantitative performance, percentage of trained parameters, and memory footprint.

|                                                 |                  |        |         |        |         |
|:------------------------------------------------|:-----------------|:-------|:--------|:-------|:--------|
| **Method**                                      |                  |        |         |        |         |
| **per task**                                    |                  |        |         |        |         |
| **(MB)**                                        | $\bm{\Delta \%}$ |        |         |        |         |
| **(min)**                                       | $\bm{\Delta \%}$ |        |         |        |         |
| T5<sub>BASE</sub>                               | 100%             | 167.99 | —       | 42.13  | —       |
| <span class="smallcaps">Adapter</span>          | 0.832%           | 124.02 | -35.45% | 31.81  | -24.50% |
| <span class="smallcaps">Pfeiffer-Adapter</span> | 0.427%           | 118.4  | -41.88% | 28.19  | -33.09% |
| <span class="smallcaps">AdapterDrop</span>      | 0.494%           | 119.41 | -40.68% | 28.08  | -33.35% |
| <span class="smallcaps">Adapter-LowRank</span>  | 0.073%           | 123.8  | -35.69% | 32.71  | -22.36% |
| <span class="smallcaps">Prompt Tuning</span>    | 0.034%           | 222.27 | 24.42%  | 44.54  | 5.72%   |
| <span class="smallcaps">Intrinsic-SAID</span>   | 0.009%           | 285.40 | 41.14%  | 144.01 | 241.82% |
| <span class="smallcaps">BitFit</span>           | 0.126%           | 102.31 | -64.20% | 27.36  | -35.06% |
| <span class="smallcaps">PHM-Adapter</span>      | 0.179%           | 123.93 | -35.55% | 35.55  | -15.62% |
| <span class="smallcaps">Compacter</span>        | 0.073%           | 123.91 | -35.57% | 36.48  | -13.41% |
| <span class="smallcaps">Compacter</span>`++`    | 0.047%           | 118.35 | -41.94% | 30.96  | -26.51% |

Percentage of trained parameters per task, average peak memory and training time for all methods. $\bm{\Delta \%}$ is the relative difference with respect to *full fine-tuning* (T5<sub>BASE</sub>). Lower is better.

Our approaches have several attractive properties. Based on our analysis in Table , <span class="smallcaps">Compacter</span> and <span class="smallcaps">Compacter</span>`++` obtain the best combination of high <span class="smallcaps">GLUE</span> score averaged across all tasks, plus a substantially lower number of parameters (0.073% and 0.047% respectively). In addition to <span class="smallcaps">Compacter</span>`++` performing well, its memory requirement is the second best among all methods, reducing memory usage by -41.94% compared to T5<sub>BASE</sub>. <span class="smallcaps">Compacter</span> and <span class="smallcaps">Compacter</span>`++` also speed up training substantially, by -13.41% and -26.51% relative to T5<sub>BASE</sub>. On the other hand, <span class="smallcaps">BitFit</span>, by not storing intermediate activations, has the lowest memory requirement (-64.2% relative to T5<sub>BASE</sub>) and is the fastest (-35.06% relative to T5<sub>BASE</sub>) at the cost of lower quantitative performance (1.53 points lower; see Table ).

Methods relying on pruning adapters, i.e., <span class="smallcaps">Pfeiffer-Adapter</span> and <span class="smallcaps">AdapterDrop</span> reduce the memory overhead and improve training time. However, their number of parameters is almost an order of magnitude more compared to <span class="smallcaps">Compacter</span>`++`, with 9.1$\times$ and 10.5$\times$ more parameters respectively. Moreover, although, <span class="smallcaps">Pfeiffer-Adapter</span> performs on par with full fine-tuning with a slight degradation (Table ), <span class="smallcaps">AdapterDrop</span> obtains a lower performance (-0.65 less on average across all tasks.). We note that dropping adapters from transformer layers is a general technique and could be applied to <span class="smallcaps">Compacter</span> for improving efficiency even further, which we leave to future work. Similarly, although <span class="smallcaps">Adapter-LowRank</span> reduces the memory overhead and improves the training time, it obtains a lower performance (Table ) (-0.68 less on average across all tasks.).

At the other end of the spectrum, <span class="smallcaps">Intrinsic-SAID</span> and <span class="smallcaps">Prompt Tuning</span> methods have the lowest number of parameters. However, they both come with high memory overhead (41.14% and 24.42% relative to full fine-tuning (T5<sub>BASE</sub>) respectively), are slowest to train, and their performance substantially lags behind full fine-tuning (see Table ). For <span class="smallcaps">Prompt Tuning</span>, high memory costs are due to the fact that the computational complexity of self-attention, which requires storing the full attention matrix for gradient computation, scales quadratically with the sequence length . For <span class="smallcaps">Intrinsic-SAID</span>, the high memory requirement is due to storing large random projection matrices, which limits the application of <span class="smallcaps">Intrinsic-SAID</span> for fine-tuning large-scale PLMs. Moreover, computing projections via FastFood transform, although theoretically possible in $O(D \log d^{\prime})$ , is slow in practice even with a CUDA implementation. For pretrained language models with a large number of parameters, allocating random projections for the full parameter space is intractable. While using Fastfood transform partially ameliorates this issue by reducing the memory usage from $\mathcal{O}(Dd^{\prime})$ to $\mathcal{O}(D)$, the memory issue with such methods remains unresolved.

Overall, given the size of large-scale transformer models with millions and billions of parameters, such as T5 , efficient memory usage is of paramount importance for practical applications. <span class="smallcaps">Compacter</span> and <span class="smallcaps">Compacter</span>`++` offer a great trade-off in terms of performance, memory usage, and training time. With regard to our inspiration of von Neumann’s quotation, we thus find that only a comparatively small number of additional parameters are necessary for the practical and efficient adaptation of PLMs.

## Low-resource Fine-tuning

<span class="smallcaps">Compacter</span>`++` has substantially fewer parameters compared to T5<sub>BASE</sub>. In this section, we investigate whether this could help <span class="smallcaps">Compacter</span>`++` to generalize better in resource-limited settings. We subsample each dataset of GLUE for varying sizes in the range $\{100, 500, 1000, 2000, 4000\}$. Figure shows the results. <span class="smallcaps">Compacter</span>`++` substantially improves the results in the low-resource setting, <span style="color: black">indicating more effective fine-tuning in this regime.</span>

<figure id="fig:lowresource_results">
<span class="image placeholder" data-original-image-src="figures/lowresource_plot.pdf" data-original-image-title="" width="50%"></span>
<figcaption>Results on GLUE for the various number of training samples per task <span class="math inline">\((100, 500, 1000, 2000, 4000)\)</span>. We show mean and standard deviation across 5 seeds.</figcaption>
</figure>

# Related Work

**Adapters** $\:$ Adapters have recently emerged as a new paradigm for fine-tuning pretrained language models . In another line of work, proposed a multilingual dependency parsing method based on adapters and contextual parameter generator networks , where they generate adapter parameters conditioned on trained input language embeddings. This, however, leads to a large number of additional parameters compared to the base model. Contemporaneously,  use a single compact hypernetwork allowing to generate adapter weights efficiently conditioned on multiple tasks and layers of a transformer model. also proposed a task-conditioned transformer for multi-task learning which is less parameter-efficient. The aforementioned work is complementary to <span class="smallcaps">Compacter</span>, and one could potentially combine <span class="smallcaps">Compacter</span> with contextual parameter generation to generate adapter modules. Compared to , <span class="smallcaps">Compacter</span>`++` reduces the parameters by 6.2$\times$.

**Hypercomplex representations** $\:$ Deep learning advances in the hypercomplex domain are in a nascent stage, and most work is fairly recent . Replacing matrix multiplications in standard networks with Hamilton products that have fewer degrees of freedom offers up to a 4$\times$ saving of parameter size in a single multiplication operation . Very recently,   extend such methods in a way that they could reduce the parameters of a fully connected layer under a mild condition to $1/n$, where $n$ is a user-specified parameter. To the best of our knowledge, there is no previous work that attempts to leverage the hypercomplex space for efficient fine-tuning of large-scale language models.

**Other parameter-efficient models** $\:$ and study training models in a low-dimensional randomly oriented subspace instead of their original parameter space. Another recent line of work has shown that pretrained models such as BERT are redundant in their capacity, allowing for significant sparsification without much degradation in end metrics . Such methods, however, remain not well supported by current hardware and often perform worse compared to dedicated efficient architectures .

# Conclusion

We have proposed <span class="smallcaps">Compacter</span>, a light-weight fine-tuning method for large-scale language models. <span class="smallcaps">Compacter</span> generates weights by summing Kronecker products between shared “slow” weights and “fast” rank-one matrices, specific to each <span class="smallcaps">Compacter</span> layer. Leveraging this formulation, <span class="smallcaps">Compacter</span> reduces the number of parameters in adapters substantially from $\mathcal{O}(kd)$ to $\mathcal{O}(k+d)$. Through extensive experiments, we demonstrate that despite learning 2127.66$\times$ fewer parameters than standard fine-tuning, <span class="smallcaps">Compacter</span> obtains comparable or better performance in a full-data setting and outperforms fine-tuning in data-limited scenarios.

# Acknowledgements

We are grateful to Dani Yogatama for feedback on a draft of this manuscript. The authors would like to thank Tuan Le for his assistance in reproducing the results of . We would like to also thank Armen Aghajanyan for his assistance to reproduce the results of his work . We thank Jue Wang for his comments on an earlier version of this paper. The authors are grateful to Brian Lester, Rami Al-Rfou, Noah Constant, and Mostafa Dehghani for their assistance. Rabeeh Karimi Mahabadi was supported by the Swiss National Science Foundation under the project Learning Representations of Abstraction for Opinion Summarization (LAOS), grant number “FNS-30216”.

# Experimental Details

#### Datasets

We run all experiments on the standard <span class="smallcaps">GLUE</span> benchmark  with Creative Commons license (CC BY 4.0) and the <span class="smallcaps">SuperGLUE</span> benchmark . These benchmark consist of multiple datasets: CoLA , SST-2 , MRPC , QQP[^9], STS-B , MNLI , QNLI , and RTE, which is a combination of data from RTE1 , RTE2 , RTE3 , RTE5 , COPA , CB , MultiRC , ReCoRD , BoolQ , and WiC  where sentences are selected from VerbNet , WordNet , and Wiktionary. We download all datasets from the HuggingFace Datasets library .

#### Low-resource fine-tuning

For the experiment conducted in , we set the number of epochs to 1000, 200, 100, 50, 25, for datasets subsampled to size 100, 500, 1000, 2000, and 4000 respectively. Based on our results, this is sufficient to allow the models to converge. We save a checkpoint every 250 steps for all models and report the results for the hyper-parameters performing the best on the validation set for each task.

#### Data pre-processing:

<span style="color: black">Following , we cast all datasets into a sequence-to-sequence format. We recast STS-B as a 21-class classification task by rounding its target scores to their nearest increment of 0.2.</span>

#### Computing infrastructure:

<span style="color: black">We run the experiments in Table , , , and  on one <span class="smallcaps">Nvidia GeForce RTX 3090</span>, and experiments in on one <span class="smallcaps">GeForce GTX 1080 Ti</span></span> GPU.

#### Training hyper-parameters:

For the experiments on <span class="smallcaps">GLUE</span>, we set the maximum sequence length to 128 and batch size to 100. Following , we use maximum sequence length of 256 for the tasks in <span class="smallcaps">SuperGLUE</span>, and for ReCoRD, we set it to 512. We used batch size of 32 for <span class="smallcaps">SuperGLUE</span>, and for ReCoRD, we set it to 16 due to the GPU memory limit. For results in , we set the batch size to 40 to match the lower GPU memory of <span class="smallcaps">GeForce GTX 1080 Ti</span> GPU. For setting the learning rates, we trained all methods with $3\mathrm{e}{-5}$, $3\mathrm{e}{-4}$, $3\mathrm{e}{-3}$, $3\mathrm{e}{-2}$, and $3\mathrm{e}{-1}$ and use the learning rate performing the best on the validation set for each method. Table  shows the final selected learning rate for each method reported in Table . For the method variants where we also fine-tune the final output layer (Table ), we report the selected learning rate in Table . We train all models with the AdamW optimizer from the HuggingFace library with default hyper-parameters of $\beta_1=0.9$, $\beta_2=0.999$, $\epsilon=1\mathrm{e}{-8}$. We set warm-up steps to 500 for all methods in Table and . We set the warm-up steps to 0 for all methods in Table and , which based on our experiments, improved the results for all methods.

| **Method**                                      | **Learning rate** |
|:------------------------------------------------|:------------------|
| T5<sub>BASE</sub>                               | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Adapter</span>          | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Pfeiffer-Adapter</span> | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">AdapterDrop</span>      | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Adapter-LowRank</span>  | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Prompt Tuning-R</span>  | $3\mathrm{e}{-2}$ |
| <span class="smallcaps">Prompt Tuning-T</span>  | $3\mathrm{e}{-1}$ |
| <span class="smallcaps">Intrinsic-SAID</span>   | $3\mathrm{e}{-2}$ |
| <span class="smallcaps">BitFit</span>           | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">PHM-Adapter</span>      | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Compacter</span>        | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Compacter</span>`++`    | $3\mathrm{e}{-3}$ |

Selected learning rates for all methods, when we also fine-tune the output layer.

| **Method**                                      | **Learning rate** |
|:------------------------------------------------|:------------------|
| <span class="smallcaps">Adapter</span>          | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Pfeiffer-Adapter</span> | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">AdapterDrop</span>      | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Adapter-LowRank</span>  | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">BitFit</span>           | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">PHM-Adapter</span>      | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Compacter</span>        | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Compacter</span>`++`    | $3\mathrm{e}{-3}$ |

Selected learning rates for all methods, when we also fine-tune the output layer.

# Impact of Hyper-parameters

In this section, we study the impact of hyper-parameters for each method reported in Table . We report the results in Table .

**Impact of dimension ($d^{\prime}$) on <span class="smallcaps">Intrinsic-SAID</span>** $\:$ Increasing the dimension $d^{\prime}$ for <span class="smallcaps">Intrinsic-SAID</span> method often improves results. Though, as discussed in  , $d^{\prime}$ is task-dependent so needs to be tuned for every new dataset to achieve optimal performance.

#### Impact of $n$ on <span class="smallcaps">PHM-Adapter</span>:

Table  shows the results for varying values of $n=\{4, 8, 12\}$. We experiment with adapters of bottleneck size $d \in \{24, 48, 96\}$.

For the T5<sub>BASE</sub> model with $k=768$, the condition $kd>n^4$ discussed in is partially satisfied for $d=24$ and $n=4,8$ and fully satisfied for $d\in\{48, 96\}$ and $n=4,8,12$. Note that this condition is satisfied for larger versions of the T5 model, i.e., T5-large (770 million parameters, $k=1024$), T5-3B (2.8 billion parameters, $k=1024$), and T5-11B (11 billion parameters, $k=1024$) with adapter hidden size $d\in\{24, 32, 48, 96\}$ and $n = 2,4,8,12$. Due to the huge computational costs of training these models, we could not run experiments on such a large scale. Nevertheless, we observe substantial parameter reduction using <span class="smallcaps">PHM-Adapter</span>.

In Table , we report the number of parameters for $d=24$ for all methods. Compared to <span class="smallcaps">Adapter</span>, <span class="smallcaps">PHM-Adapter</span> with $n=8$ reduces the parameters substantially by 5.2$\times$.

#### Impact of $n$ on <span class="smallcaps">Compacter</span>:

For <span class="smallcaps">Compacter</span> and <span class="smallcaps">Compacter</span>`++`, we observe that the number of trainable parameters is almost constant across different values of $n$. This is due to the fact that the number of trainable parameters in layernorms (LN) and biases (B) in each LPHM layer make up a high proportion of parameters for our methods. For instance for $n=4$, for <span class="smallcaps">Compacter</span> with 0.073% of trainable parameters, LN and B make up 28.49% and 23.51% respectively of its trainable parameters; for <span class="smallcaps">Compacter</span>`++` with 0.047% of trainable parameters, LN and B make up 44.01% and 18.15% respectively of its parameters; while for <span class="smallcaps">PHM-Adapter</span> with 0.239% of trainable parameters, LN and B make up only 8.63% and 7.12% respectively of its parameters. Consequently, simply removing biases from adapters, and exploring ideas of training language models without layer normalizations  can be promising directions on reducing parameters further, which we leave to future work.

<span class="smallcaps">Compacter</span> has more than an order of magnitude fewer parameters compared to <span class="smallcaps">Adapter</span>, with a parameter reduction at a remarkable rate of 11.4$\times$. <span class="smallcaps">Compacter</span>`++` even reduces the parameters further by 17.7$\times$ in total.

# Results with Fine-tuning the Output Layer

Table  shows the results for the methods in Table  with fine-tuning the output layer. The parameters of the output layer dominate the parameters of each method and thus reduce the relative parameter savings. The standard adapter obtains the largest improvement in performance when fine-tuning the output layer compared to the results in Table . In contrast, our proposed methods perform well with or without fine-tuning the output layer.

# Results on <span class="smallcaps">SuperGLUE</span>

Table  shows the performance of our proposed methods on <span class="smallcaps">SuperGLUE</span> for different values of $n$. We include the learning rate obtaining the best validation performance for all methods reported in Table  in Table .

# Impact of Model Size

Table  shows the results of methods using T5<sub>SMALL</sub>(60M parameters) on <span class="smallcaps">GLUE</span>. For all adapter-based methods, we experiment with adapters of bottleneck size of $\{16, 32, 64\}$. For our methods, we experiment with $n=\{4, 8, 16\}$.

All parameter-efficient fine-tuning methods are performing worse than full fine-tuning with this small model size. This is in contrast to the results of Table  and  , where some parameter-efficient fine-tuning methods were able to perform on par or outperform full fine-tuning with the larger model size of T5<sub>BASE</sub>(222M parameters). Among all methods, adapters, and our proposed methods perform the best. We report the learning rate performing the best on the validation set of each method in Table .

| **Method**                                      | **Learning rate** |
|:------------------------------------------------|:------------------|
| T5<sub>SMALL</sub>                              | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Adapter</span>          | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Pfeiffer-Adapter</span> | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">AdapterDrop</span>      | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Adapter-LowRank</span>  | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Prompt Tuning-R</span>  | $3\mathrm{e}{-2}$ |
| <span class="smallcaps">Prompt Tuning-T</span>  | $3\mathrm{e}{-1}$ |
| <span class="smallcaps">Intrinsic-SAID</span>   | $3\mathrm{e}{-2}$ |
| <span class="smallcaps">BitFit</span>           | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">PHM-Adapter</span>      | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Compacter</span>        | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Compacter</span>`++`    | $3\mathrm{e}{-3}$ |

Selected learning rates for all methods with T5<sub>BASE</sub> on <span class="smallcaps">SuperGLUE</span>.

| **Method**                                      | **Learning rate** |
|:------------------------------------------------|:------------------|
| T5<sub>BASE</sub>                               | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Adapter</span>          | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Pfeiffer-Adapter</span> | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">AdapterDrop</span>      | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Adapter-LowRank</span>  | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Prompt Tuning-R</span>  | $3\mathrm{e}{-2}$ |
| <span class="smallcaps">Prompt Tuning-T</span>  | $3\mathrm{e}{-1}$ |
| <span class="smallcaps">BitFit</span>           | $3\mathrm{e}{-4}$ |
| <span class="smallcaps">Intrinsic-SAID</span>   | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">PHM-Adapter</span>      | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Compacter</span>        | $3\mathrm{e}{-3}$ |
| <span class="smallcaps">Compacter</span>`++`    | $3\mathrm{e}{-3}$ |

Selected learning rates for all methods with T5<sub>BASE</sub> on <span class="smallcaps">SuperGLUE</span>.

[^1]: We do not factorize $\bm{A_i}$ as they are small, shared between all layers, and factorization hurts performance.

[^2]: If factors are over-parameterized, <span class="smallcaps">Compacter</span> can be used for *overcomplete* knowledge distillation .

[^3]: Even for smaller models where the $n^4$ term dominates, we observe a substantial reduction of parameters compared to adapters.

[^4]: Following , as a common practice, we do not experiment with WNLI  due to its adversarial nature with respect to the training set.

[^5]: This is much more efficient as the output layer includes 11.1% of the parameters of T5<sub>BASE</sub>. Tasks are formulated in a text-to-text format so the model can be applied to them without learning a new output layer . We note that this is in contrast to the original adapter setting, which used an encoder-only masked PLM .

[^6]: For <span class="smallcaps">BitFit</span>, we only update the biases. For <span class="smallcaps">Prompt Tuning</span>, the entire model is frozen.

[^7]: Note that in the HuggingFace T5 implementation, the biases in layer normalizations, linear layers, the output layer and self-attention layers are removed. We re-introduce these biases for <span class="smallcaps">BitFit</span>.

[^8]: We found this to slightly outperform keeping the <span class="smallcaps">Compacter</span> layer after the self-attention layer instead.

[^9]: <https://data.quora.com/First-Quora-Dataset-Release-Question-Pairs>
